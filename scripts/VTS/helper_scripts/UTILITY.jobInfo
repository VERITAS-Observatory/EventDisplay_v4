#!/bin/bash
# written by Nathan Kelley-Hoskins
# May 2014
# version 1.0

CORED="\033[0;31m"
COBLUE="\033[0;34m"
CONORM="\033[0;00m"
STORAGEFLAG="" # short or long
SELFNAME=$( basename $0 )

# check for right number of arguments
ISPIPEFILE=`readlink /dev/fd/0` # check to see if input is from terminal, or from a pipe
#echo "\$ISPIPEFILE: '$ISPIPEFILE'"
if [[ "$ISPIPEFILE" =~ ^/dev/pts/[0-9]{1,2} && "$#" < "1" ]] ; then # its a terminal (not a pipe)
    #echo "terminal"
    echo "For displaying information about a completed batch job."
    echo "$ $SELFNAME <runnumber>"
    exit 1
#else
    #echo "pipe"
fi

function getInputs {
    if read -t 0 ; then
        cat
    else
        echo "$@"
    fi
}

# tokenize all job numbers
RAWJOBNUM=$( getInputs "$@")
#echo "RAWJOBNUM '$RAWJOBNUM'"
JOBLIST=()
for jobnum in $RAWJOBNUM ; do
    #echo "$jobnum"
    JOBLIST+=( $jobnum )
done

if [[ "${#JOBLIST[@]}" != "1" ]] ; then
    echo "Error, only one job number allowed, you submitted '${JOBLIST[@]}', exiting..."
    exit 2
fi

# check if inputs are numbers
for jobnum in "${JOBLIST[@]}" ; do
    if [[ "$jobnum" =~ [^0-9] ]] ; then
        echo "Error, non-number detected in '$jobnum', exiting..."
        echo "Input must be an integer, e.g:"
        echo "  $ $SELFNAME 1175496"
        exit 3
    fi
done

# check if job number is currently running,
# quit if it still is
if command -v qstat > /dev/null 2>&1 ; then
    for jobnum in "${JOBLIST[@]}" ; do
        JOBISRUNNING=$( qstat -u $USER | grep -P "^$jobnum" )
        #echo "JOBISRUNNING:'$JOBISRUNNING'"
        if [[ ! -z "$JOBISRUNNING" ]] ; then
            echo "Job '$jobnum' is still running, please wait until it's done."
            exit 4
        fi
    done
else
    echo "error, can't find program 'qstat'... are you sure you have access to a cluster?"
    exit 5
fi


# program for checking short-term job info storage

# see if qacct exists
# job information is first stored here
SHORTBIN=qacct
if command -v $SHORTBIN > /dev/null 2>&1 ; then
    CHECKSHORT=true
else
    CHECKSHORT=false
    echo "warning, can't find '$SHORTBIN', will skip checking for job info with this method"
fi

# see if arcx exists
# after being done for 20 minutes, the job info
# gets moved to arcx
LONGBIN=arcx
if command -v $LONGBIN > /dev/null 2>&1 ; then
    CHECKLONG=true
else
    CHECKLONG=false
    echo "warning, can't find '$LONGBIN', will skip checking for job info with this method"
fi

# fail if we don't have binaries
if [[ ! $CHECKSHORT && ! $CHECKLONG ]] ; then
    echo "error, can't find either '$SHORTBIN' or '$LONGBIN', so we can't check job statuses at all."
    echo "I suggest asking the people who manage your cluster about these two programs..."
    return 1
fi
    
# did we successfully get job data?
DIDWEGETJOBDATA=no

# check short term job info storage
if $CHECKSHORT ; then
    # check short-term job info
    JOBTEXT=$( $SHORTBIN -j ${JOBLIST[@]} 2>&1 )
    #echo "JOBTEXT 1 '$JOBTEXT'"
    if [[ ! "$JOBTEXT" =~ "error: job id" ]] ; then
        # format the text, 1 task per line
        JOBTEXT=$( echo "$JOBTEXT" | sed '/[=]/d' | awk '{ argname=$1; $1=""; therest=$0; printf "%s = %s\n", argname, therest }' | sed -e 's|=  |= |g' | tr '\n' ' ' |sed -e 's|qname|\nqname|g' | sed -e '/^\s*$/d' )
        #echo "Accessing short-term job information with 'qacct -j $JOBNUM'"
        STORAGEFLAG=short
        DIDWEGETJOBDATA=yes
        #echo "Short Term" ; echo "'$JOBTEXT'"
    fi

fi
        
# check long term job info storage
if [[ $CHECKLONG && $DIDWEGETJOBDATA == no ]] ; then
    JOBTEXT=$( $LONGBIN sgejobs $JOBLIST 2>&1 )
    #echo "JOBTEXT 2 '$JOBTEXT'"
    if [[ ! "$JOBTEXT" =~ "no jobs submitted for user" ]] ; then
        # format things, 1 task per line
        JOBTEXT=$( echo "$JOBTEXT" | sed 's/^\t//' | tr '\n' ' ' | sed -e 's|qname|\nqname|g' | sed -e '/^\s*$/d' )
        #echo "Accessing long-term job information with 'arcx sgejobs $JOBNUM'..."
        STORAGEFLAG=long
        DIDWEGETJOBDATA=yes
        #echo "Long Term" ; echo "'$JOBTEXT'"
    fi
fi
            
if [[ $DIDWEGETJOBDATA == no ]] ; then
    echo "error, unable to find info for job number(s) '${JOBNUM[@]}', are you sure thats the right number?"
    exit 6
fi


# loop over tasks
ANYPROBLEMS="no"
while read -r LINE ; do
    #echo
    #echo "$LINE"
    #echo
    
    # get info about each task
    EXITSTAT=$(   echo "$LINE" | grep -oP "exit_status = \d+" | grep -oP "\d+" )
    FAILEDCODE=$( echo "$LINE" | grep -oP "failed = \d+"      | grep -oP "\d+" )
    if   [[ $STORAGEFLAG == short ]] ; then
        JOBNUM=$(   echo "$LINE" | grep -oP "jobnumber = \d+" | grep -oP "\d+" )
        TASKNUM=$(  echo "$LINE" | grep -oP "taskid = \d+"    | grep -oP "\d+" )
        JOBSTART=$( echo "$LINE" | grep -oP "start_time = .+ end_time" | awk '{ $1=""; $2="" ; $8="" ; print $0 }' | sed -e 's/^ *//' -e 's/ *$//' )
        JOBEND=$(   echo "$LINE" | grep -oP "end_time = .+ granted_pe" | awk '{ $1=""; $2="" ; $8="" ; print $0 }' | sed -e 's/^ *//' -e 's/ *$//' )
        JOBSTART=$( date -d "$JOBSTART" +%s )
        JOBEND=$(   date -d "$JOBEND"   +%s )
    elif [[ $STORAGEFLAG == long  ]] ; then
        JOBNUM=$(   echo "$LINE" | grep -oP "job_number = \d+"  | grep -oP "\d+" )
        TASKNUM=$(  echo "$LINE" | grep -oP "task_number = \d+" | grep -oP "\d+" )
        JOBSTART=$( echo "$LINE" | grep -oP "start_time = \d+"  | grep -oP "\d+" )
        JOBEND=$(   echo "$LINE" | grep -oP "end_time = \d+"    | grep -oP "\d+" )
    fi
    #echo "JOBSTART '$JOBSTART'"
    #echo "JOBEND   '$JOBEND'"
    JOBDUR=$(( JOBEND - $JOBSTART ))
    JOBDURTXT=$( date -u -d @${JOBDUR} +"%T" )
    
    # construct the exit status text
    if [[ "$FAILEDCODE" != "0" && "$FAILEDCODE" != "100" ]] ; then
        echo -e "${CORED}Error, potential failure on the cluster side, contact the cluster's maintainers (failed=$FAILEDCODE)$CONORM"
    fi
    
    if [[ "$EXITSTAT" != "0" || "$FAILEDCODE" != "0" ]] ; then
        ANYPROBLEMS="yes"
        # code=
        if [[ "$EXITSTAT" == "137" ]] ; then
            EXITREASON="Job went over time limit"
            EXITSUGFIX="-> Suggestion: Increase h_rt and/or h_cpu"
        else
            EXITREASON="Unknown"
            EXITSUGFIX=""
        fi
        EXITINF=$( printf "(bad) exit_code = %3d  failed = %3d" $EXITSTAT $FAILEDCODE )
        EXITINFO="${CORED}${EXITINF}${CONORM}"
        #EXITINFO="${CORED}(bad) exit_code = ${EXITSTAT}  failed = ${FAILEDCODE}$CONORM" # Cause:${EXITREASON}$CONORM ${COBLUE}$EXITSUGFIX $CONORM"
    else
        EXITINFO="(ok ) exit_code =   $EXITSTAT"
    fi
    
    # print info for the user
    echo -e "Job:$JOBNUM  task:$TASKNUM  duration:$JOBDURTXT  $EXITINFO"
done < <(echo "$JOBTEXT")

# properly return an exit status, so external programs
# can react to bad jobs easily
if [[ "$ANYPROBLEMS" == "yes" ]] ; then
    exit 7
else
    exit 0
fi
