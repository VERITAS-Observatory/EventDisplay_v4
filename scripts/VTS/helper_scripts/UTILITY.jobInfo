#!/bin/bash
# written by Nathan Kelley-Hoskins
# May 2014
# version 1.0

CORED="\033[0;31m"
COBLUE="\033[0;34m"
CONORM="\033[0;00m"
STORAGEFLAG="" # short or long
SELFNAME=$( basename $0 )

# check for right number of arguments
ISPIPEFILE=`readlink /dev/fd/0` # check to see if input is from terminal, or from a pipe
#echo "\$ISPIPEFILE: '$ISPIPEFILE'"
if [[ "$ISPIPEFILE" =~ ^/dev/pts/[0-9]{1,2} && "$#" < "1" ]] ; then # its a terminal (not a pipe)
    #echo "terminal"
    echo "For displaying information about a completed batch job."
    echo "$ $SELFNAME <sge job number>"
	echo "note: just the job number, not the jobnumber.taskid (yes=38717234, no=12842248.1-8:2)"
    exit 1
#else
    #echo "pipe"
fi

JOBNUM="$1"
if [[ "$JOBNUM" =~ [^0-9] ]] ; then
	echo "Error, non-number detected in '$JOBNUM', exiting..."
	echo "Input must be an integer, e.g:"
	echo "  $ $SELFNAME 1175496"
	echo "note: just the job number, not the jobnumber.taskid (yes=38717234, no=12842248.1-8:2)"
	echo "note: will get the latest job number's info"
	exit 3
fi

# check if job number is currently running,
# quit if it still is
if command -v qstat > /dev/null 2>&1 ; then
	JOBISRUNNING=$( qstat -u $USER | grep -P "^$JOBNUM" )
	#echo "JOBISRUNNING:'$JOBISRUNNING'"
	if [[ ! -z "$JOBISRUNNING" ]] ; then
		echo "Job '$JOBNUM' is still running, please wait until it's done."
		exit 4
	fi
else
    echo "error, can't find program 'qstat'... are you sure you have access to a cluster?"
    exit 5
fi


# program for checking short-term job info storage

# see if qacct exists
# job information is first stored here
SHORTBIN=qacct
if command -v $SHORTBIN > /dev/null 2>&1 ; then
    CHECKSHORT=true
else
    CHECKSHORT=false
    echo "warning, can't find '$SHORTBIN', will skip checking for job info with this method"
fi

# see if arcx exists
# after being done for 20 minutes, the job info
# gets moved to arcx
LONGBIN=arcx
if command -v $LONGBIN > /dev/null 2>&1 ; then
    CHECKLONG=true
else
    CHECKLONG=false
    echo "warning, can't find '$LONGBIN', will skip checking for job info with this method"
fi

# fail if we don't have binaries
if [[ ! $CHECKSHORT && ! $CHECKLONG ]] ; then
    echo "error, can't find either '$SHORTBIN' or '$LONGBIN', so we can't check job statuses at all."
    echo "I suggest asking the people who manage your cluster about these two programs..."
    return 1
fi
    
# did we successfully get job data?
DIDWEGETJOBDATA=no

# check short term job info storage
if $CHECKSHORT ; then
    # check short-term job info
    #JOBTEXT=$( $SHORTBIN -j ${JOBLIST[@]} 2>&1 )
    JOBTEXT=$( $SHORTBIN -j $JOBNUM 2>&1 )
    #echo "JOBTEXT 1 '$JOBTEXT'"
    if [[ ! "$JOBTEXT" =~ "error: job id" ]] ; then
        # format the text, 1 task per line
        JOBTEXT=$( echo "$JOBTEXT" | sed '/[=]/d' | awk '{ argname=$1; $1=""; therest=$0; printf "%s = %s\n", argname, therest }' | sed -e 's|=  |= |g' | tr '\n' ' ' |sed -e 's|qname|\nqname|g' | sed -e '/^\s*$/d' )
        #echo "Accessing short-term job information with 'qacct -j $JOBNUM'"
        STORAGEFLAG=short
        DIDWEGETJOBDATA=yes
        #echo "Short Term" ; echo "'$JOBTEXT'"
    fi
fi
        
# check long term job info storage
if [[ $CHECKLONG && $DIDWEGETJOBDATA == no ]] ; then
    #JOBTEXT=$( $LONGBIN sgejobs $JOBLIST 2>&1 )
    JOBTEXT=$( $LONGBIN sgejobs $JOBNUM 2>&1 )
    #echo "JOBTEXT 2 '$JOBTEXT'"
    if [[ ! "$JOBTEXT" =~ "no jobs submitted for user" ]] ; then
        # format things, 1 task per line
        JOBTEXT=$( echo "$JOBTEXT" | sed 's/^\t//' | tr '\n' ' ' | sed -e 's|qname|\nqname|g' | sed -e '/^\s*$/d' )
        #echo "Accessing long-term job information with 'arcx sgejobs $JOBNUM'..."
        STORAGEFLAG=long
        DIDWEGETJOBDATA=yes
        #echo "Long Term" ; echo "'$JOBTEXT'"
    fi
fi
            
if [[ $DIDWEGETJOBDATA == no ]] ; then
    echo "error, unable to find info for job number(s) '${JOBNUM[@]}', are you sure thats the right number?"
    exit 6
fi


# loop over tasks
ANYPROBLEMS="no"

# need to find the latest job submission time (short:qsub_time or long:submission_time)
#echo "JOBNUM:$JOBNUM"
if [[ $STORAGEFLAG == short ]] ; then
	#echo "SHORT!"
	LATESTJOBSUBTIME="0"
	LATESTJOBSUBTIMEF=""
	while read JOBTEXTLINE ; do
		SUBTIMEFORM=$( echo "$JOBTEXTLINE" | grep -oP "qsub_time .+ start_time " | awk '{ $1=""; $2="" ; $8="" ; print $0 }' | sed -e 's/^ *//' -e 's/ *$//' )
		#echo "SUBTIMEFORM:'$SUBTIMEFORM'"
		SUBTIME=$( date -d "$SUBTIMEFORM" +%s )
		#echo "SUBTIME:'$SUBTIME'"
		if (( $SUBTIME > $LATESTJOBSUBTIME )) ; then
			LATESTJOBSUBTIME=$SUBTIME
			LATESTJOBSUBTIMEF="$SUBTIMEFORM"
		fi
	done < <(echo "$JOBTEXT")
	#echo "LATEST:$LATESTJOBSUBTIME - '$LATESTJOBSUBTIMEF'"
	LATESTLINES=$(echo "$JOBTEXT" | grep "jobnumber = $JOBNUM" | grep "qsub_time = $LATESTJOBSUBTIMEF")
	#LATESTLINES=$(echo "$JOBTEXT" | grep "qsub_time = $LATESTJOBSUBTIMEF")
elif [[ $STORAGEFLAG == long ]] ; then
	#echo "LONG!"
	SUBTIME=$( echo "$JOBTEXT" | grep -oP "submission_time = \d+" | grep -oP "\d+" | awk '{ if(max==""){max=$1}; if ($1>max){max=$1}; count+=1} END {print max}' )
	#echo "$SUBTIME"
	LATESTLINES=$( echo "$JOBTEXT" | grep "submission_time = $SUBTIME" | grep "job_number = $JOBNUM" )
fi

#echo "LATESTLINES:"
#echo "$LATESTLINES"

if [ -z "$LATESTLINES" ] ; then
	echo "Error, could not get job info, exiting..." 2>&1
	exit 1
fi

#echo
#exit 0

while read -r LINE ; do
#    echo
#    echo "line:'$LINE'"
    #echo
    
    # get info about each task
    EXITSTAT=$(   echo "$LINE" | grep -oP "exit_status = \d+" | grep -oP "\d+" )
    FAILEDCODE=$( echo "$LINE" | grep -oP "failed = \d+"      | grep -oP "\d+" )
    if   [[ $STORAGEFLAG == short ]] ; then
        JOBNUM=$(   echo "$LINE" | grep -oP "jobnumber = \d+" | grep -oP "\d+" )
        TASKNUM=$(  echo "$LINE" | grep -oP "taskid = (\d+|undefined)"  | awk '{print $3}')
        JOBSUBTI=$( echo "$LINE" | grep -oP "qsub_time = .+ start_time" | awk '{ $1=""; $2="" ; $8="" ; print $0 }' | sed -e 's/^ *//' -e 's/ *$//' )
        JOBSTART=$( echo "$LINE" | grep -oP "start_time = .+ end_time"  | awk '{ $1=""; $2="" ; $8="" ; print $0 }' | sed -e 's/^ *//' -e 's/ *$//' )
        JOBEND=$(   echo "$LINE" | grep -oP "end_time = .+ granted_pe"  | awk '{ $1=""; $2="" ; $8="" ; print $0 }' | sed -e 's/^ *//' -e 's/ *$//' )
        JOBSTART=$( date -d "$JOBSTART" +%s )
        JOBEND=$(   date -d "$JOBEND"   +%s )
		JOBSUBTIME=$( date -d "$JOBSUBTI" +%s )
		#echo "JOBSUBTI:'$JOBSUBTI'" 2>&1
		#echo "SHORT:JOBSUBTIME:'$JOBSUBTIME'" 2>&1
		
    elif [[ $STORAGEFLAG == long  ]] ; then
        JOBNUM=$(     echo "$LINE" | grep -oP "job_number = \d+"      | grep -oP "\d+" )
        TASKNUM=$(    echo "$LINE" | grep -oP "task_number = \d+"     | grep -oP "\d+" )
        JOBSUBTIME=$( echo "$LINE" | grep -oP "submission_time = \d+" | grep -oP "\d+" )
        JOBSTART=$(   echo "$LINE" | grep -oP "start_time = \d+"      | grep -oP "\d+" )
        JOBEND=$(     echo "$LINE" | grep -oP "end_time = \d+"        | grep -oP "\d+" )
    fi
    #echo "JOBSTART '$JOBSTART'"
    #echo "JOBEND   '$JOBEND'"
    JOBDUR=$(( JOBEND - $JOBSTART ))
    JOBDURTXT=$( date -u -d @${JOBDUR} +"%T" )
	#echo "JOBSUBTIME:'$JOBSUBTIME'" 2>&1
	JOBSUBTIMEF=$( date -d @${JOBSUBTIME} +"%Y-%m-%d %H:%M:%S" )
	JOBSUBTIMESTRING="submitted:$JOBSUBTIMEF"
    
    # construct the exit status text
    if [[ "$FAILEDCODE" != "0" && "$FAILEDCODE" != "100" ]] ; then
        echo -e "${CORED}Error, potential failure on the cluster side, contact the cluster's maintainers (failed=$FAILEDCODE)$CONORM"
    fi
    
    if [[ "$EXITSTAT" != "0" || "$FAILEDCODE" != "0" ]] ; then
        ANYPROBLEMS="yes"
        # code=
        if [[ "$EXITSTAT" == "137" ]] ; then
            EXITREASON="Job went over time limit"
            EXITSUGFIX="-> Suggestion: Increase h_rt and/or h_cpu"
        else
            EXITREASON="Unknown"
            EXITSUGFIX=""
        fi
        EXITINF=$( printf "(bad) exit_code = %3d  failed = %3d" $EXITSTAT $FAILEDCODE )
        EXITINFO="${CORED}${EXITINF}${CONORM}"
        #EXITINFO="${CORED}(bad) exit_code = ${EXITSTAT}  failed = ${FAILEDCODE}$CONORM" # Cause:${EXITREASON}$CONORM ${COBLUE}$EXITSUGFIX $CONORM"
    else
        EXITINFO="(ok ) exit_code =   $EXITSTAT"
    fi
    
	if [ "$TASKNUM" == "undefined" ] ; then
		TASKSTRING="      "
	else
		TASKSTRING="task:$TASKNUM"
	fi
	
    # print info for the user
    echo -e "job:$JOBNUM  $TASKSTRING  $JOBSUBTIMESTRING  runtime:$JOBDURTXT  $EXITINFO"
done < <(echo "$LATESTLINES")
#done < <(echo "$JOBTEXT")
exit 0

# properly return an exit status, so external programs
# can react to bad jobs easily
if [[ "$ANYPROBLEMS" == "yes" ]] ; then
    exit 7
else
    exit 0
fi
