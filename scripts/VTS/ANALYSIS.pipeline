#!/bin/bash
CWD=$PWD
########################################
#
# Written by Nathan Kelley-Hoskins
# Feb 2013
#

########################################################
# HOW DO I USE THIS ?                                  #
# put this in a new directory,                         #
# add your runlist file to that directory,             #
# edit the settings below, then use the commands       #
# $ ANALYSIS.pipeline [evndisp|mscw|anpar|anmer]       #
# to run stages of the analysis,                       #
# $ ANALYSIS.pipeline jobs                             #
# to see currently running jobs, and                   #
# $ ANALYSIS.pipeline [evndisp|mscw|anpar|anmer] check #
# to check the results of each stage for errors        #
########################################################

#############################################################################
#
# // do not change the stuff in the square brackets in the next line, it is needed for the 'options' keyword
# [BEGIN ANALYSIS SETTINGS 3823984]

## Which Runlist file should we use?
# Which runlist do you want to use?
# It should be a simple list of veritas runnumbers,
# one per line.  Used in all stages.
# (full path please)
export RUNLIST="$CWD/runlist.crab.dat"

## Should we use the Model3D feature?
# use Model3D feature(yes/no)
# Takes effect in the evndisp stage.
export USEMODEL3D="no"

## What kind of cuts do you want to use?
# Currently supports:
#    'Soft', 'Moderate', 'Hard', 
#    'SoftOpen', 'ModerateOpen', 'SuperHard'
# Takes effect in the anpar stage.
export CUTS="Moderate"

## What kind of background do you want to use?
# 'ring' or 'refl' (for reflected)
# Takes effect in the anpar stage.
export BACKGROUND="refl" # ring or [refl, reflect, reflected]
#
# If using the 'ring' background method:
# How how big should the radius of the the 'on' region be, in degrees?
export RINGCENT="0.5"
# and how big should the 'off' ring be, in units of 'on'-region areas?
export RINGAREA="10"
#
# If using the reflected(refl) background method:
# what should be the minimum distance between off region edges, in degrees?
export REFLWOBOFF="0.5"
# whats the minimum number of off regions we require?
export REFLMINREG="1"
# and the maximum number of off regions we require?
export REFLMAXREG="10"

## Should we produce the tzero and pedestal files first?
# These are required to do an analysis.
# Takes effect in the evndisp stage.
# yes/no
export DOCALIB=yes

## Where should we store the evndisp and mscw output files?
# Takes effect in the evndisp stage.
# (full path please)
# evndisp files will be: $EVNDISPOUTPUTDIR/#####.root, #####.tzero.root, etc
# mscw files will be put in RecIDX within this directory (see next option)
export EVNDISPOUTPUTDIR="$VERITAS_USER_DATA_DIR/analysis/Results/EVD-v423/"

## Which Reconstruction ID (RecID) should we use?
# 0, 1, 2, 3, or 4
# 0 = do mscw stage with all available images
# 1 = do mscw stage without using T1 images
# 2 = do mscw stage without using T2 images
# 3 = do mscw stage without using T3 images
# 4 = do mscw stage without using T4 images
# Takes effect in the mscw stage.
## For regular data analysis, this should be 0
export RECID=0

## Should we use the frogs feature?
# In the anasum stage, should we use frogs datafiles as the input?
# If no, we will use the mscw datafiles instead.
# To create the frogs datafiles, just run the 'frogs' stage.
## Attention: To use this feature properly, after the 'mscw' stage, 
## you must run the 'frogs' stage for this option to fully take effect.
# yes/no
export USEFROGS="no"

## Where should the frogs's output files be stored?
# Takes effect in the frogs stage.
# (full path please)
export FROGSOUTPUTDIR="$EVNDISPOUTPUTDIR/frogs"

## Where should we put the anasum output files (parallel and merged)?
# Takes effect in the anpar stage.
# (full path please)
export ANASUMOUTPUTDIR="$CWD/arf"

## What should we name the final merged anasum
# output root file? It will be put in $ANASUMOUTPUTDIR
# Takes effect in the anmer stage.
# Filename only, not full path.
export FINALOUTPUT="anmer.output.root"

## Which anasum runparameter file should we use?
# Takes effect in the anpar stage.
# (full path please)
export RUNPARAMFILE="$VERITAS_EVNDISP_AUX_DIR/ParameterFiles/ANASUM.runparameter.Crab"

## For the Effective Area and Radial Acceptance Files, whats the minimum
## number of telescopes we require?
# Should be 2, 3, or 4.
export AUXFILE_MINTEL="2"

## Are we analysing a point source, or an extended source?
# The Effective Area and Radial Acceptance files depend on this setting.
# Either 'PointSource' or 'ExtendedSource'
export AUXFILE_SRCEXT="PointSource"

## Do you want to use the DISP feature?
# This will change how image axes and their intersection
# are calculated.
# (yes/no)
export SCIPIPE_USEDISP="yes"
# if you said yes, you should also make sure to use the right
# event display reconstruction parameter file, stored in
# $VERITAS_EVNDISP_AUX_DIR/ParameterFiles
# Availible files are:
#   EVNDISP.reconstruction.runparameter.DISP
#   EVNDISP.reconstruction.runparameter.SumWindow6-noDISP
#   EVNDISP.reconstruction.runparameter.SumWindow6-DISP
# SumWindow:
#   SumWindow6     should be used with grisu-derived IRF files
#   non-SumWindow6 should be used with care-derived  IRF files
export EVNDISPRECONFILE="EVNDISP.reconstruction.runparameter.SumWindow6-DISP"

## For your Effective Area, Radial Acceptance, and Table IRF files:
#
# Which event display version should they have been made with?
# e.g. effArea-v447-auxv01-CARE_June1425-Cut-NTel2-PointSource-SoftOpen-ID0-V6-ATM21-T1234.root
#              ^^^^
# radialAcceptance-v447-auxv01-Cut-NTel2-ExtendedSource-Hard-ID0-V6-T1234.root
#                  ^^^^
# table-v447-auxv01-CARE_June1425-ATM21-V6-ID0.root
#       ^^^^
# Should have the format 'v###', like 'v447' or 'v525', etc.
export AUXFILE_EVNVER="v447"
#
# Which simulation type should they have been made with?
# e.g. effArea-v447-auxv01-CARE_June1425-Cut-NTel2-PointSource-SoftOpen-ID0-V6-ATM21-T1234.root
#                          ^^^^^^^^^^^^^
# Should have the format '<simtype>_<month><year><day>', like 'CARE_June1425' 
# or for grisu just 'GRISU-SW6'
export AUXFILE_SIMDATE="CARE_June1425"
#
# For the radial acceptance IRF file, what aux-file-version should we use?
# e.g. radialAcceptance-v447-auxv01-Cut-NTel2-ExtendedSource-Hard-ID0-V6-T1234.root
#                            ^^^^^^
# Should have the format 'auxv##', e.g. 'auxv01' or 'auxv31'
export AUXVER_RADEC="auxv01"
#
# For the table IRF file, what aux-file-version should we use?
# e.g. table-v447-auxv01-CARE_June1425-ATM21-V6-ID0.root
#                 ^^^^^^
# Should have the format 'auxv##', e.g. 'auxv01' or 'auxv31'
export AUXVER_TABLE="auxv01"
#
# For the effective area IRF file, what aux-file-version should we use?
# e.g. effArea-v447-auxv01-CARE_June1425-Cut-NTel2-PointSource-SoftOpen-ID0-V6-ATM21-T1234.root
#                   ^^^^^^
# Should have the format 'auxv##', e.g. 'auxv01' or 'auxv31'
export AUXVER_EFFAREA="auxv01"

## Which directory should we keep any ctools datafiles we produce with the 'mutate' command?
# Takes effect in the mutate stage.
export CTOOLSDIR="$CWD/ctoolsdata"

## Should we use manually-defined laser runs for some runs?
# Takes effect in the evndisp stage.
# (yes/no)
export SCIPIPE_MANUALLASER="no"
# If yes, which calibration file should we use to manually define 
# which runs have which laser runs?
# The calibration file should be in $VERITAS_EVNDISP_AUX_DIR/Calibration ,
# and should have the same format as calibrationlist.dat in that directory.
export SCIPIPE_MANUALLASERFILE="calibrationlist.dat"

## The above options should be put into a separate config 
## file 'analysis.config' to override the above default settings.
# A blank 'analysis.config' file can be created via:
#   $ ANALYSIS.pipeline newconfig
# This config file should be in the same directory as the 
#   ANALYSIS.pipeline script (or a link to the pipeline).
# The config file is a 'bash' script, obeying all 'bash' syntax.
# These options must each be preceded by 'export', like so:
# export RUNLIST="$CWD/runlist.cygnus.dat"
# export BACKGROUND="refl"
# export REFLWOBOFF="0.8"
# export CUTS="soft"


# [END ANALYSIS SETTINGS 843230239] 
# // do not change the line above,
# // doing so will interfere with the 'options' keyword
# // the number is random so the regex doesn't match itself
#
###########################################################################################


ANAPIPENAME="$0"
if [[ $# < 1 || ! $1 =~ (evndisp|mscw|frogs|anpar|anmer|mutate|options|settings|newconfig|jobs|kill|devopts|xxf) ]] ; then 
    echo "
HOW DO I USE THIS ?                             

   1. Make a project directory, and make a soft link to \$EVNDISPSYS/scripts/VTS/ANALYSIS.pipeline, via
      $ ln -s \$EVNDISPSYS/scripts/VTS/ANALYSIS.pipeline

   2. Add your runlist file to your project directory

   3. Create a new analysis config file 'analysis.config' in your project directory:
      $ ./$ANAPIPENAME newconfig

   4. View all the options you can add to 'analysis.config':
      $ ./$ANAPIPENAME options
	
   5. Add your runlist filename and any options to your 'analysis.config'.
      Options should have the same format as in a bash file:

      export RUNLIST=crab.runlist
      export CUTS="Moderate"

      etc.

   6. Run a stage of the analysis:
		
        i) Submit stage jobs to the cluster:
        $ $ANAPIPENAME [evndisp|mscw|frogs|anpar|anmer|mutate]                
		
        ii) Check if jobs are done:
        $ $ANAPIPENAME jobs
		
        iii) Check the results of the stage for errors
        $ $ANAPIPENAME [evndisp|mscw|frogs|anpar|anmer|mutate] check
		

Stages of Event Display: [evndisp|mscw|frogs|anpar|anmer],
  (optional 'check' afterwards)
  $ $ANAPIPENAME evndisp         # run the 'event display' stage
  $ $ANAPIPENAME evndisp check   # after evndisp, check its log and datafiles for problems
  $ $ANAPIPENAME mscw            # run the 'mean scaled width' stage
  $ $ANAPIPENAME mscw check      # after mscw, check its log and datafiles for problems
  $ $ANAPIPENAME frogs           # run the 'frogs image reconstruction' stage
  $ $ANAPIPENAME frogs check     # after frogs, check its log and datafiles for problems
  $ $ANAPIPENAME anpar           # run the 'anasum parallel' stage
  $ $ANAPIPENAME anpar check     # after anpar, check its log and datafiles for problems
  $ $ANAPIPENAME mutate          # after anpar, convert anasum parallel files to ctool's fits format
  $ $ANAPIPENAME mutate check    # after anpar, check the mutate stage's log and datafiles
  $ $ANAPIPENAME anmer           # after anpar, merge the anasum parallel files to one anasum file

Other commands:
  $ $ANAPIPENAME options   # print descriptions of all analysis options ('settings' also works)
  $ $ANAPIPENAME newconfig # create a new (blank) analysis.config file, will refuse to overwrite any existing one
  $ $ANAPIPENAME jobs      # show progress of all of this project's jobs, updating every 90 seconds, until all jobs are done
  $ $ANAPIPENAME kill      # halt all of this project's jobs
  $ $ANAPIPENAME devopts   # see developer options
"
	exit 1
fi

exec 5>&1 # extra place to duplicate output to stdout, look for >&5

# don't change the next line, doing so will mess up the 'devopts' pipeline keyword
# [BEGIN DEVELOPER OPTIONS 348234]

## To scan the logfiles for custom keywords:
# any lines matching $SCIPIPE_DEBUGREGEX will be
# shown in blue when 'check'ing stages
# It is a regex pattern(google it), 
# e.g. "NKH|WHITEBOARD" will highlight any 
# logfile lines containing "NKH" or "WHITEBOARD" .
# It is used as a Perl-style Regex, aka:
#   $ grep -P $SCIPIPE_DEBUGREGEX logfilename
# This will work in addition to the warning and
#   error scanning.
export SCIPIPE_DEBUGREGEX="WHITEBOARD"

## To only test the first 10000 events:
# if set to yes, some stages will only run
# for the first few hundred events
# to allow for very fast testing
# Do not set this to 'yes' and expect good science!
export SCIPIPE_FASTDEVMODE="no"

## If you want the pipeline to not use colored text:
# you can use the SCIPIPE_COLOROPT environment variable.
# To only turn off colors in the command $ ANALYSIS.pipeline options, (or 'settings') use
# export SCIPIPE_COLOROPT="nooptions"
# To only turn off colors in the output of the stage 'check's, use 
# export SCIPIPE_COLOROPT="nologs"
# To turn off both, use 
# export SCIPIPE_COLOROPT="nooptions:nologs"
export SCIPIPE_COLOROPT=""

# [END DEVELOPER OPTIONS 385239482]
# don't change the above line, doing so will mess up the 'devopts' pipeline keyword

STAGE=$1
CHK=$2
if [ "$CHK" = "check" ] ; then
	CHECKFLAG=true
else
	CHECKFLAG=false
fi

SETTINGSFILE="analysis.config"

if [ "$STAGE" = "newconfig" ] ; then
	if [ -f "$SETTINGSFILE" ] ; then
		echo "Error, config file '$SETTINGSFILE' already exists.  Please move or rename the existing one before creating a new '$SETTINGSFILE' file.  Exiting..." 2>&1
		exit 1
	else
		BASHPATH=$( which bash )

		echo "#!${BASHPATH}"                              >> "$SETTINGSFILE"
		echo "export RUNLIST=\"YourRunlistFileNameHere\"" >> "$SETTINGSFILE"
		echo "export CUTS=\"Moderate\"                  " >> "$SETTINGSFILE"
		echo "export BACKGROUND=\"reflected\"           " >> "$SETTINGSFILE"
		echo "export RUNPARAMFILE=\"$VERITAS_EVNDISP_AUX_DIR/ParameterFiles/ANASUM.runparameter.Crab\"" >> "$SETTINGSFILE"
		
		echo
		echo "Now creating '$SETTINGSFILE' for you... done."
		echo
		echo "You should now edit '$SETTINGSFILE' to contain your runlist"
		echo "  filename, your anasum parameter file (RUNPARAMFILE), and any"
		echo "  other options you want in your analysis."
		echo
		echo "All options can be shown by doing '$ $ANAPIPENAME options'"
		echo
	fi
	
	exit 0
fi

function colorOutput {
	
	local OPTLINES="$1"

	# check for color settings, don't print color text if 'noptions' is in SCIPIPE_COLOROPT
	if [[ "$SCIPIPE_COLOROPT" =~ nooptions ]] ; then
		OPTREDD=''
		OPTBLUE=''
		OPTGREE=''
		OPTNORM=''
	else
		OPTREDD='\033[22;31m'
		OPTBLUE='\033[22;34m'
		OPTGREE='\033[22;32m'
		OPTNORM='\033[0m'
	fi

	while read -r line ; do
		#echo "line: '$line'"
		# if the line starts with a comment '#', make it blue, otherwise print the line green
		if [[ "$line" =~ ^## ]] ; then 
			line2=$( echo "$line" | sed -E 's/^##/#/' )
			echo -e "${OPTREDD}${line2}${OPTNORM}"
		elif [[ "$line" =~ ^# ]] ; then
			echo -e "${OPTBLUE}${line}${OPTNORM}"
		else
			echo -e "${OPTGREE}${line}${OPTNORM}"
		fi
	done <<< "$OPTLINES"

}

# settings file, any settings in this file will override the above settings
if [ -f "$SETTINGSFILE" ] ; then
	echo "Loading additional pipeline settings from '$SETTINGSFILE'..."
	source "$SETTINGSFILE"
fi


#if [ "$STAGE" = "options" ] ; then
if [[ "$STAGE" =~ (options|settings) ]] ; then
	echo
	echo "#######################################################"
	echo "Analysis Options that you can add to '$SETTINGSFILE':"
	echo "#######################################################"

	# print all the lines of this script that are between 
	# the BEGIN ANALYSIS SETTINGS and END ANALYSIS SETTINGS
	# (followed with a number)
	OPTLINES=$( cat "$ANAPIPENAME" | sed -n '/\[BEGIN ANALYSIS SETTINGS [0-9]\+\]/,/\[END ANALYSIS SETTINGS [0-9]\+\]/p' | tail -n +2 | head -n -1)

	# print with colors
	colorOutput "$OPTLINES"
	echo
	
	exit 0
fi

if [[ "$STAGE" =~ devopts ]] ; then
	echo
	echo "########################################################"
	echo "Developer Options that you can add to '$SETTINGSFILE':"
	echo "########################################################"

	# print all the lines of this script that are between 
	# the BEGIN ANALYSIS SETTINGS and END ANALYSIS SETTINGS
	# (followed with a number)
	OPTLINES=$( cat "$ANAPIPENAME" | sed -n '/\[BEGIN DEVELOPER OPTIONS [0-9]\+\]/,/\[END DEVELOPER OPTIONS [0-9]\+\]/p'  | tail -n +2 | head -n -1 )
	
	# print with colors
	colorOutput "$OPTLINES"
	echo
	
	exit 0
fi

# check that $EVNDISPSYS is sane
if [ ! -d "$EVNDISPSYS" ] ; then
	echo "error, \$EVNDISPSYS='$EVNDISPSYS' isn't a valid directory, exiting..." 2>&1
	exit 1
fi

# check that $VERITAS_EVNDISP_AUX_DIR is sane
if [ ! -d "$VERITAS_EVNDISP_AUX_DIR" ] ; then
	echo "error, \$VERITAS_EVNDISP_AUX_DIR='$VERITAS_EVNDISP_AUX_DIR' isn't a valid directory, exiting..." 2>&1
	exit 1
fi

# check that the runlist is sane
if [ ! -e "$RUNLIST" ] ; then
	echo "error, \$RUNLIST=$RUNLIST needs to be a valid file, exiting..." 2>&1
	exit 1
fi

# directory for storing information about stages, jobs, etc
SCIDIR="$CWD/.pipeline"
mkdir -p $SCIDIR

# extra functions
source $EVNDISPSYS/scripts/VTS/helper_scripts/pipeline_functions.sh

if [[ "$SCIPIPE_FASTDEVMODE" == "yes" ]] ; then
	echo -e "${COTYELLOW}Warning, \$SCIPIPE_FASTDEVMODE is set to 'yes', evndisp stage will only process the first 2000 events...$CONORM"
fi

# evndisp output directory
mkdir -p $EVNDISPOUTPUTDIR

# frogs output directory
mkdir -p $FROGSOUTPUTDIR

# anasum output directory
mkdir -p $ANASUMOUTPUTDIR

# ctools output directory
mkdir -p $CTOOLSDIR

# check that $SCIPIPE_MANUALLASERFILE is a valid
# file in $VERITAS_EVNDISP_AUX_DIR/Calibration
if [[ "$SCIPIPE_MANUALLASER" == "yes" ]] ; then
	if [[ ! -f "$VERITAS_EVNDISP_AUX_DIR/Calibration/$SCIPIPE_MANUALLASERFILE" ]] ; then
		echo -e "${COTRED}Error, you specified 'SCIPIPE_MANUALLASER=yes', but the file specified by 'SCIPIPE_MANUALLASERFILE=$SCIPIPE_MANUALLASERFILE' doesn't seem to exist.  Use 'SCIPIPE_MANUALLASER=no', or figure out the right file for SCIPIPE_MANUALLASERFILE, exiting...$CONORM"
		exit 1
	fi
fi

# alert the user if they are using FASTDEVMODE
function checkForFASTDEVMODE {
    if [ "$FASTDEVMODE" = "yes" ] ; then
        echo -e "${COTYELLOW}Warning, \$FASTDEVMODE=yes, not all events will be processed (this variable is set in ANALYSIS.pipeline)...${CONORM}"
    fi
}

STAGEFILE="$SCIDIR/stage"
RUNNINGJOBS="$SCIDIR/runningjobs" # file containing job numbers from the last action
if [[ "$1" == "jobs" ]] ; then # print run status
    checkIfJobsAreDoneAlt "$RUNNINGJOBS" "$STAGEFILE" 30
fi

if [[ "$1" == "kill" ]] ; then # kill all running jobs
    killJobsInJobfile "$RUNNINGJOBS"
fi


function setupFilteredRunlists {
	if [[ "$SCIPIPE_USEDISP" == "yes" ]] ; then
		#TABLEDISPCODE="ID1"
		METHCODE="DISP"
	else
		#TABLEDISPCODE="ID0"
		METHCODE="GEO"
	fi
	
	#TABLEFILEWINTV4="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM21-V4-${TABLEDISPCODE}"
	#TABLEFILESUMMV4="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM22-V4-${TABLEDISPCODE}"
	#TABLEFILEWINTV5="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM21-V5-${TABLEDISPCODE}"
	#TABLEFILESUMMV5="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM22-V5-${TABLEDISPCODE}"
	#TABLEFILEWINTV6="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM21-V6-${TABLEDISPCODE}"
	#TABLEFILESUMMV6="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM22-V6-${TABLEDISPCODE}"

	TABLEFILEWINTV4="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM21-V4-$METHCODE"
	TABLEFILESUMMV4="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM22-V4-$METHCODE"
	TABLEFILEWINTV5="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM21-V5-$METHCODE"
	TABLEFILESUMMV5="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM22-V5-$METHCODE"
	TABLEFILEWINTV6="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM21-V6-$METHCODE"
	TABLEFILESUMMV6="$VERITAS_EVNDISP_AUX_DIR/Tables/table-${AUXFILE_EVNVER}-${AUXVER_TABLE}-${AUXFILE_SIMDATE}-ATM22-V6-$METHCODE"

	RUNLISTSUMMV4="$SCIDIR/runlist.summer.V4"
	RUNLISTWINTV4="$SCIDIR/runlist.winter.V4"
	RUNLISTSUMMV5="$SCIDIR/runlist.summer.V5"
	RUNLISTWINTV5="$SCIDIR/runlist.winter.V5"
	RUNLISTSUMMV6="$SCIDIR/runlist.summer.V6"
	RUNLISTWINTV6="$SCIDIR/runlist.winter.V6"
	cd $EVNDISPSYS/scripts/VTS
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 4 > $RUNLISTSUMMV4
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 4 > $RUNLISTWINTV4
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 5 > $RUNLISTSUMMV5
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 5 > $RUNLISTWINTV5
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 6 > $RUNLISTSUMMV6
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 6 > $RUNLISTWINTV6
	cd $CWD
}

# make list of run-specific parameter files
PARAMFILELIST="$SCIDIR/paramfilelist.dat"
ANASUMRUNLIST="$CWD/AnasumRunList.dat"
RUNNUMBERS=`cat $RUNLIST`
function makeParamFile {
    rm -rf $PARAMFILELIST
    rm -rf $ANASUMRUNLIST
    # generate basic param files
	#$EVNDISPSYS/scripts/VTS/helper_scripts/pipeline_generateParamFiles.sh "$CUTS" "$GAMHADCUTDATE" "$RADECDATE" "$EFDATE1" "$EFDATE2" "$TABLEDATE" 3 "$USEFROGS" "$RUNLIST" > "$PARAMFILELIST"
	
	# Pack all the settings into a one-line argument.
	# Characters that will break this: if any options have '~' or ':' or ' ' in them, 
	# as these are used as delimiters in this packing technique.
	SETTINGLINE="~CUTS:$CUTS~AUXFILEEVNVER:$AUXFILE_EVNVER~AUXFILESIMDATE:$AUXFILE_SIMDATE~AUXVERRADEC:$AUXVER_RADEC~AUXVEREFFAREA:$AUXVER_EFFAREA~AUXVERTABLE:$AUXVER_TABLE~AUXFILEMINTEL:$AUXFILE_MINTEL~USEFROGS:$USEFROGS~AUXFILESRCEXT:$AUXFILE_SRCEXT~AUXFILEDISP:$SCIPIPE_USEDISP~"
	#echo "SETTINGLINE:'$SETTINGLINE'"
	$EVNDISPSYS/scripts/VTS/helper_scripts/pipeline_generateParamFiles.sh "$SETTINGLINE" "$RUNLIST" > "$PARAMFILELIST"
	PARAMEXIT="$?"
	#echo "PARAMEXIT:$PARAMEXIT" # =0 if ok, !=0 if bad things happened
	if [[ "$PARAMEXIT" != "0" ]] ; then # had a problem generating param files
		echoerr "${COTRED}Error, had a problem generating parameter files (see above text), exiting pipeline...$CONORM"
		exit 1
	fi
    
    # now put these filenames in the AnasumRunList format
    # fill AnasumRunList with each run's info
    # GENERATE ANASUMRUNLIST
    #echo "" > $ANASUMRUNLIST
    rm -rf "$ANASUMRUNLIST"
	echo "Making Param File, using $BACKGROUND background method"
    for ARUN in $RUNNUMBERS ; do
        ARCUTSFILE=$(      grep "RUN$ARUN" "$PARAMFILELIST" | grep -oE "\S*ANASUM.GammaHadron\S*" )
        AREFFAREAFILE=$(   grep "RUN$ARUN" "$PARAMFILELIST" | grep -oE "\S*effArea\S*"            )
        ARRADIALACCFILE=$( grep "RUN$ARUN" "$PARAMFILELIST" | grep -oE "\S*radialAcceptance\S*"   ) 
		if [[ -z "$ARCUTSFILE" || -z "$AREFFAREAFILE" || -z "$ARRADIALACCFILE" ]] ; then
			echo -e "${COTRED}Error, couldn't determine an IRF file for Run $ARUN :"
			if [[ -z "$ARCUTSFILE"      ]] ; then echo -e "${COTRED}   GammaHadronCut   File:'$ARCUTSFILE'      $CONORM" ; fi
			if [[ -z "$AREFFAREAFILE"   ]] ; then echo -e "${COTRED}   EffectiveArea    File:'$AREFFAREAFILE'   $CONORM" ; fi
			if [[ -z "$ARRADIALACCFILE" ]] ; then echo -e "${COTRED}   RadialAcceptance File:'$ARRADIALACCFILE' $CONORM" ; fi
			exit 1
		fi

        #ARRADIALACCFILE="imgselAcceptFile.root"
		if [[ $BACKGROUND == ring ]] ; then
            echo "* $ARUN $ARUN 0 $ARCUTSFILE 1 $AREFFAREAFILE $RINGCENT $RINGAREA $ARRADIALACCFILE" >> $ANASUMRUNLIST
		elif [[ $BACKGROUND == refl* ]] ; then
            echo "* $ARUN $ARUN 0 $ARCUTSFILE 2 $AREFFAREAFILE $REFLWOBOFF $REFLMINREG $REFLMAXREG $ARRADIALACCFILE" >> $ANASUMRUNLIST
		else
			echo -e "${COTRED}Error, unrecognized background keyword '$BACKGROUND', must be 'ring' or 'refl', exiting...${CONORM}"
			exit 1
        fi
    done
}


# take output from qsub commands, and parse it
# for job numbers, usually:
# Your job ##########
# and add it to the runningJobList
function updateRunningJobFile {
    local INPUTDATA="$1"
    local ACTIVEJOBS=$( echo "$QSUBDATA" | grep -oP "JOBID [0-9.-:]+" | awk '{print $2}' )
    rm -rf "$RUNNINGJOBS" ;
    for AJOB in $ACTIVEJOBS ; do
        #echo "updateRunningJobFile: Adding job: $AJOB"
        echo "$AJOB" >> $RUNNINGJOBS
    done
}

function stageBanner {
	if $CHECKFLAG ; then
		BANNER="Checking the $STAGE Stage ~~~~~~~~~~~"
	else
		BANNER="Running the $STAGE Stage ~~~~~~~~~~~~"
	fi
	echo -e "${COTBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$CONORM"
	echo -e "${COTBLUE}~~~~ $BANNER$CONORM"
	echo -e "${COTBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$CONORM"
}

# test stage for just making the param file, and nothing else
if [[ "$STAGE" == "xxf" ]] ; then
	stageBanner
	echo "\$VERITAS_EVNDISP_AUX_DIR:$VERITAS_EVNDISP_AUX_DIR"
	echo "\$EVNDISPSYS:$EVNDISPSYS"
	makeParamFile
	exit 0
fi

# print out the chunk of this script that describes all
# of the analysis options the user can use


# s1 event display
if [[ "$STAGE" == "evndisp" ]] ; then
	EVNJOBSUB="$SCIDIR/qsubdata.evndisp"
	if ! $CHECKFLAG ; then 
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# evndisp #########################################################
		echo "$STAGE" > "$STAGEFILE"
		makeParamFile
        checkForFASTDEVMODE
		cd $EVNDISPSYS/scripts/VTS
        if [[ "$DOCALIB" = yes ]] ; then CALIBCODE=1
        else                             CALIBCODE=0 ; fi
        VPM=1 ## on by default
        if [[ "$USEMODEL3D" == "yes" ]] ; then MODEL3D=1
        else                                   MODEL3D=0 ; fi
		QSUBDATA=$(./ANALYSIS.evndisp.sh $RUNLIST $EVNDISPOUTPUTDIR $EVNDISPRECONFILE $CALIBCODE $MODEL3D | tee >(cat - >&5) )
		rm -rf "$EVNJOBSUB"
		echo "$QSUBDATA" > "$EVNJOBSUB"
		updateRunningJobFile "$QSUBDATA"
		
	else # check the stage results
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# evndisp check #########################################################
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$EVNJOBSUB" $SCIPIPE_DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$EVNJOBSUB" "$RUNLIST"
        echo
        
		QSUBDATA=$(cat "$EVNJOBSUB")
		while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }')
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $SCIPIPE_DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $SCIPIPE_DEBUGREGEX
            
            if [ "$DOCALIB" == "yes" ] ; then
                PEDLOG=$(   cat "$OLOG" | grep "RUN$ARUN PEDLOG"   | awk '{ print $3 }' )
                if filenameIsNotHealthy "$PEDLOG" "PEDLOG" "pedestal log file" "$OLOG"        ; then continue ; fi
                checkLogFileForProblems "$PEDLOG" $SCIPIPE_DEBUGREGEX
                
                TZEROLOG=$( cat "$OLOG" | grep "RUN$ARUN TZEROLOG" | awk '{ print $3 }' )
                if filenameIsNotHealthy "$TZEROLOG" "TZEROLOG" "tzero log file" "$OLOG"       ; then continue ; fi
                checkLogFileForProblems "$TZEROLOG" $SCIPIPE_DEBUGREGEX
            fi

            EVNDISPLOG=$(   cat "$OLOG" | grep "RUN$ARUN EVNDISPLOG" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$EVNDISPLOG" "EVNDISPLOG" "evndisp log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$EVNDISPLOG" $SCIPIPE_DEBUGREGEX
            
            checkLogFileForStageSuccess "$EVNDISPLOG" "Final checks on result file (seems to be OK):"
		done < $RUNLIST
		
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		OLOG=$( echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG" | head -n 1 | awk '{ print $4 }' )
        if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then echo -e "${COTRED}Error, Probably can't find datafiles, because we can't find the batch stdout log file...$CONORM" ; fi
        
		DFDIR=$( cat $OLOG | grep -P "^RUN\d{5} EVNDISPLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo -e "~~~~~~~~~~~ Evndisp Datafiles stored in $DFDIR/ $CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(    echo "$RUNDATA"  | grep -P "^RUN $ARUN OLOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then continue ; fi
            
			ELOG=$(    echo "$RUNDATA"  | grep -P "^RUN $ARUN ELOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG" | grep "RUN$ARUN EVNDISPDATA"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "EVNDISPDATA" "evndisp datafile" "$OLOG"   ; then continue ; fi
            
            if [ "$DOCALIB" == "yes" ] ; then
                PEDLOG=$(   cat "$OLOG" | grep "RUN$ARUN PEDLOG"   | awk '{ print $3 }' )
                if filenameIsNotHealthy "$PEDLOG" "PEDLOG" "pedestal log file"  "$OLOG" ; then continue ; fi
                
                TZEROLOG=$( cat "$OLOG" | grep "RUN$ARUN TZEROLOG" | awk '{ print $3 }' )
                if filenameIsNotHealthy "$TZEROLOG" "TZEROLOG" "tzero log file" "$OLOG" ; then continue ; fi
            fi
            
            EVNDISPLOG=$(   cat "$OLOG" | grep "RUN$ARUN EVNDISPLOG"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$EVNDISPLOG" "EVNDISPLOG" "evndisp log file" "$OLOG"  ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$EVNDISPLOG" )
            if [ "$DOCALIB" == "yes" ] ; then
                LOGFILES+=( "$PEDLOG" "$TZEROLOG" )
            fi
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$EVNDISPLOG" "Final checks on result file (seems to be OK):")
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST
		
		exit 0
	fi
fi

# s2 mscw
if [[ "$STAGE" == "mscw" ]] ; then
	MSCWJOBSUB="$SCIDIR/qsubdata.mscw"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# mscw #########################################################
		echo "$STAGE" > "$STAGEFILE"
        checkForFASTDEVMODE
		setupFilteredRunlists
		makeParamFile
		cd $EVNDISPSYS/scripts/VTS
		#./VTS.MSCW_ENERGY.sub_analyse_data.sh $TABLEFILE $EVNDISPOUTPUTDIR $RUNLIST
		QSUBDATA=""
		NRUNS=$( cat $RUNLISTWINTV4 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $TABLEFILEWINTV4 $RUNLISTWINTV4 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV4 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $TABLEFILESUMMV4 $RUNLISTSUMMV4 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTWINTV5 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $TABLEFILEWINTV5 $RUNLISTWINTV5 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV5 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $TABLEFILESUMMV5 $RUNLISTSUMMV5 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTWINTV6 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $TABLEFILEWINTV6 $RUNLISTWINTV6 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV6 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $TABLEFILESUMMV6 $RUNLISTSUMMV6 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		rm -rf "$MSCWJOBSUB"
		echo "$QSUBDATA" > "$MSCWJOBSUB"
		updateRunningJobFile "$QSUBDATA"
	else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# mscw check #########################################################
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$MSCWJOBSUB" $SCIPIPE_DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$MSCWJOBSUB" "$RUNLIST"
        echo
        
		QSUBDATA=$(cat "$MSCWJOBSUB")
		while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$MSCWJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $SCIPIPE_DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $SCIPIPE_DEBUGREGEX
            
            MSCWLOG=$(   cat "$OLOG" | grep "RUN$ARUN MSCWLOG"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$MSCWLOG" "MSCWLOG" "mscw log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$MSCWLOG" $SCIPIPE_DEBUGREGEX
            
            checkLogFileForStageSuccess "$MSCWLOG" "...outputfile closed"
		done < $RUNLIST

		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"    | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d{5} MSCWLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo
		echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ MSCW Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN OLOG"     | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$MSCWJOBSUB" ; then continue ; fi
            
			ELOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN ELOG"     | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$MSCWJOBSUB" ; then continue ; fi
            
            MSCWLOG=$(  cat "$OLOG"      | grep "RUN$ARUN MSCWLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$MSCWLOG"  "MSCWLOG"  "mscw log file" "$OLOG"   ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG"      | grep "RUN$ARUN MSCWDATA" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "MSCWDATA" "mscw datafile" "$OLOG"   ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$MSCWLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$MSCWLOG" "...outputfile closed" )
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST
	fi
fi

# s3 frogs 
if [[ "$STAGE" == "frogs" ]] ; then
    FROGSJOBSUB="$SCIDIR/qsubdata.frogs"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# frogs #################################################################
		echo "$STAGE" > "$STAGEFILE"
		cd $EVNDISPSYS/scripts/VTS
        checkForFASTDEVMODE
		setupFilteredRunlists
		makeParamFile
        
        # frogs ########################################################
		QSUBDATA=$( ./ANALYSIS.evndisp_frogs.sh "$RUNLIST" "$FROGSOUTPUTDIR" "$EVNDISPOUTPUTDIR/RecID${RECID}" 0 | tee >(cat - >&5) )
		
		updateRunningJobFile "$QSUBDATA"
		rm -rf "$FROGSJOBSUB"
        echo "$QSUBDATA" > "$FROGSJOBSUB"
        sleep 2
	else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# frogs check #########################################################
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$FROGSJOBSUB" $SCIPIPE_DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$FROGSJOBSUB" "$RUNLIST"
        
        # scan all log files
        QSUBDATA=$( cat $FROGSJOBSUB )
		while read ARUN ; do
            echo
			echo -e "${COBLUE}~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$FROGSJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $SCIPIPE_DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$FROGSJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $SCIPIPE_DEBUGREGEX
            
            FROGSLOG=$( cat "$OLOG" | grep "RUN$ARUN FROGSLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$FROGSLOG" "FROGSLOG" "frogs log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$FROGSLOG" $SCIPIPE_DEBUGREGEX
            
            checkLogFileForStageSuccess "$FROGSLOG" "Final checks on result file (seems to be OK)"
		done < $RUNLIST

		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"     | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d+ FROGSLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo
		echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ FROGS Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN OLOG"      | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG"     "OLOG"      "$HUMANBATCHSTDOUT" "$FROGSJOBSUB" ; then continue ; fi
            
			ELOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN ELOG"      | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG"     "ELOG"      "$HUMANBATCHSTDERR" "$FROGSJOBSUB" ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG"      | grep "RUN$ARUN FROGSDATA" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "FROGSDATA" "frogs datafile"    "$OLOG"        ; then continue ; fi
            
            FROGSLOG=$( cat "$OLOG"      | grep "RUN$ARUN FROGSLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$FROGSLOG" "FROGSLOG"  "frogs log file"    "$OLOG"        ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$FROGSLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$FROGSLOG" "Final checks on result file (seems to be OK)" )
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST
	fi
fi

# s4 anasum_parallel (anpar)
if [[ "$STAGE" == "anpar" ]] ; then
	ANPARJOBSUB="$SCIDIR/qsubdata.anpar"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# anpar #########################################################
		makeParamFile
		echo "$STAGE" > "$STAGEFILE"
        checkForFASTDEVMODE
		cd $EVNDISPSYS/scripts/VTS
		
		# decide input directory
        if [[ "$USEFROGS" == "yes" ]] ; then 
            INPUTANASUMDIR="$FROGSOUTPUTDIR"
            echo -e "${COTYELLOW}Using frogs files as input...$CONORM"
        else
            INPUTANASUMDIR="$EVNDISPOUTPUTDIR/RecID${RECID}"
            echo -e "Using mscw files as input..."
        fi
		
		QSUBDATA=$( ./ANALYSIS.anasum_parallel.sh "$ANASUMRUNLIST" "$INPUTANASUMDIR" "$ANASUMOUTPUTDIR" "$RUNPARAMFILE" | tee >(cat - >&5) )
		updateRunningJobFile "$QSUBDATA"
		rm -rf "$ANPARJOBSUB"
        echo "$QSUBDATA" > "$ANPARJOBSUB"
        sleep 2
	else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# anpar check #########################################################
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$ANPARJOBSUB" $SCIPIPE_DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$ANPARJOBSUB" "$RUNLIST"
        echo
        
		QSUBDATA=$( cat $ANPARJOBSUB )
		for ARUN in $RUNNUMBERS ; do # check batch and log files
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$( echo "$RUNDATA" | grep "RUN $ARUN OLOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$ANPARJOBSUB" ; then continue ; fi
			checkLogFileForProblems "$OLOG" $SCIPIPE_DEBUGREGEX
            
			ELOG=$( echo "$RUNDATA" | grep "RUN $ARUN ELOG" | awk '{ print $4 }' )
			checkLogFileForProblems "$ELOG" $SCIPIPE_DEBUGREGEX
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$ANPARJOBSUB" ; then continue ; fi
            
            ANPARLOG=$( cat "$OLOG" | grep "RUN$ARUN ANPARLOG" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$ANPARLOG" "ANPARLOG" "anasum parallel log file" "$OLOG" ; then continue ; fi
            checkLogFileForProblems "$ANPARLOG" $SCIPIPE_DEBUGREGEX
             
            checkLogFileForStageSuccess "$ANPARLOG" "analysis results written to"
		done < $RUNLIST
		
		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"     | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d{5} ANPARLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ ANASUM Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$ANPARJOBSUB"        ; then continue ; fi
            
            ANPARLOG=$(  cat "$OLOG" | grep "RUN$ARUN ANPARLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$ANPARLOG" "ANPARLOG" "anasum parallel log file" "$OLOG"  ; then continue ; fi
            
            DATAFILE=$(  cat "$OLOG" | grep "RUN$ARUN ANPARDATA"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "ANPARDATA" "anasum parallel datafile" "$OLOG"   ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$ANPARLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            RUNSIGMA=$( grep -E "ALL RUNS" "$ANPARLOG" | grep -oP '\d{1,3}\.\d{0,2} sigma' | grep -oP '\d{1,3}\.\d{0,2}')
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$ANPARLOG" "analysis results written to" )
            printf "%10s is %s, last modified %19s sigma=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$RUNSIGMA" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
            
		done < $RUNLIST

	fi
fi

# s5 anasum
if [[ "$STAGE" == "anmer" ]] ; then
	FINALOUTPUTLOG="${ANASUMOUTPUTDIR}/`basename $FINALOUTPUT .root`.log"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# anmer #############################################################################
		makeParamFile
		echo "$STAGE" > "$STAGEFILE"
		cd $EVNDISPSYS/scripts/VTS
		nice -n 19 ./ANALYSIS.anasum_combine.sh $ANASUMRUNLIST $ANASUMOUTPUTDIR $FINALOUTPUT $RUNPARAMFILE | tee "$FINALOUTPUTLOG"
		updateRunningJobFile ""
     
    else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# anmer check ######################################################################
        if filenameIsNotHealthy "$FINALOUTPUTLOG" "(filename constructed in ANALYSIS.pipeline)" "merged anasum log file" "ANALYSIS.pipeline"  ; then continue ; fi
		checkLogFileForProblems $FINALOUTPUTLOG $SCIPIPE_DEBUGREGEX
        
		DATAFILE="${ANASUMOUTPUTDIR}/${FINALOUTPUT}"
        if filenameIsNotHealthy "$DATAFILE" "FINALOUTPUT" "merge anasum datafile" "ANALYSIS.pipeline"  ; then continue ; fi
        
        LOGFILES=( "$FINALOUTPUTLOG" )
        WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
        ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
        RUNSIGMA=$( grep -E "ALL RUNS" "$FINALOUTPUTLOG" | grep -oP '\d{1,3}\.\d{0,2} sigma' | grep -oP '\d{1,3}\.\d{0,2}')
        
        DFBASE=$( basename $DATAFILE )
        DFSIZE=`stat -c %s $DATAFILE`
        DFSIZESTR=$( formatFileSize "$DFSIZE" )
        DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
        printf "%10s is %s, last modified %19s sigma=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$RUNSIGMA" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
	fi
fi

# s6 mutate : (convert) Anasum Parallel files to CTOOL's Data Format$
if [[ "$STAGE" == "mutate" ]] ; then
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		
		# check that anasum run parameter file has the WRITEEVENTTREEFORCTOOLS
		GOODSETTING=$( cat "$RUNPARAMFILE" | grep -P "^\*\s+WRITEEVENTTREEFORCTOOLS\s+1")
		if [ -z "$GOODSETTING" ] ; then
			echo -e "${COTYELLOW}Warning, you're trying to convert anasum files to ctool's fits format, but ${COTRED}these anasum files may not have been made with the '* WRITEEVENTTREEFORCTOOLS 1' option${COTYELLOW} in its Anasum Parameter File: '$RUNPARAMFILE'${CONORM}"
			echo -e "${COTYELLOW}  There is a very good chance this stage will fail.$CONORM"
		fi
		
        
		# mutate ###################################################3
        cd $EVNDISPSYS/bin
        echo "now here: $PWD"
        echo "output data going here: $CTOOLSDIR"
        while read ARUN ; do
            # this stage runs quite fast (~10seconds per run)
            # so we wont run it in parallel
            #echo "$ANASUMOUTPUTDIR/$ARUN.anasum.root"
            echo "Producing $CTOOLSDIR/$ARUN.ctools.fits ..."
            writeCTAEventListFromAnasum -f -i "$ANASUMOUTPUTDIR/$ARUN.anasum.root" -o "$CTOOLSDIR/$ARUN.ctools.fits" >  "$CTOOLSDIR/$ARUN.ctools.log" 2>&1  
            #echo
        done < $RUNLIST
        
    else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# mutate check ###################################################3
        
        # check log files
        while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
            CTOOLSLOG="$CTOOLSDIR/$ARUN.ctools.log"
            checkLogFileForProblems     "$CTOOLSLOG" $SCIPIPE_DEBUGREGEX
            checkLogFileForStageSuccess "$CTOOLSLOG" "Conversion from .* complete"
        done < $RUNLIST
        
        # check data files
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ CTOOLS Datafiles stored in $CTOOLSDIR/$CONORM"
        while read ARUN ; do
            LOGFILES=("$CTOOLSDIR/$ARUN.ctools.log" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DATAFILE="$CTOOLSDIR/$ARUN.ctools.fits"
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            NEVENTS=$( cat "$CTOOLSDIR/$ARUN.ctools.log" | grep -P "RunNumber \d+, \d+ events written." | grep -oP ", \d+ events" | grep -oP "\d+" )
            RUNSUCCESS=$( checkForSuccess "$CTOOLSDIR/$ARUN.ctools.log" "Conversion from .* complete" )
            printf "%10s is %s, last modified %19s events=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$NEVENTS" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
        done < $RUNLIST
    fi
fi
