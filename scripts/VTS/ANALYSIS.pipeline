#!/bin/bash
CWD=$PWD
########################################
#
# Written by Nathan Kelley-Hoskins
# Feb 2013
#

########################################################
# HOW DO I USE THIS ?                                  #
# put this in a new directory,                         #
# add your runlist file to that directory,             #
# edit the settings below, then use the commands       #
# $ ANALYSIS.pipeline [evndisp|mscw|anpar|anmer]       #
# to run stages of the analysis,                       #
# $ ANALYSIS.pipeline jobs                             #
# to see currently running jobs, and                   #
# $ ANALYSIS.pipeline [evndisp|mscw|anpar|anmer] check #
# to check the results of each stage for errors        #
########################################################

#############################################################################
#
# ANALYSIS SETTINGS:
#

# Which event display installation do you want to use?
# if not set, you must have EVNDISPSYS defined ($ echo "$EVNDISPSYS" )
# (full path please)
#export EVNDISPSYS="/afs/ifh.de/user/n/nkelhos/scratch/VERITAS/EVNDISP/EVNDISP-400/trunk"

# Which runlist do you want to use?
# It should be a simple list of veritas runnumbers,
# one per line.
# (full path please)
RUNLIST="$CWD/runlist.crab.dat"

# What kind of cuts do you want to use?
# Currently supports 'soft', 'moderate', or 'hard'
CUTS="soft"

# What kind of background do you want to use?
# 'ring' or 'refl' (for reflected)
BACKGROUND="refl" # ring or [refl, reflect, reflected]

# If using 'ring' background, 
# how how big should the radius of the the 'on' region be, in degrees?
RINGCENT="0.5"
# and how big should the 'off' ring be, in units of 'on'-region areas?
RINGAREA="10"

# if using 'refl' background,
# what should be the minimum distance between off region edges, in degrees?
REFLWOBOFF="0.5"
# whats the minimum number of off regions we should use?
REFLMINREG="1"
# and the maximum number of off regions to use?
REFLMAXREG="10"

# Should we produce the tzero and pedestal files first?
# These are required to do an analysis.
# yes/no
DOCALIB=no

# Where should we store the evndisp and mscw output files?
# (full path please)
# evndisp files will be: $EVNDISPDIR/#####.root, #####.tzero.root, etc
# mscw files will be 
EVNDISPDIR="$VERITAS_USER_DATA_DIR/analysis/Results/EVD-v423/"

# Which Reconstruction ID (RecID) should we use?
# 0, 1, 2, 3, or 4
# 0 = do mscw stage with all availible images
# 1 = do mscw stage without using T1 images
# 2 = do mscw stage without using T2 images
# etc.
# For regular data analysis, this should be 0
RECID=0

# In the anasum stage, should we use frogs datafiles as the input?
# If no, we will use the mscw datafiles instead.
# To create the frogs datafiles, just run the 'frogs' stage.
# ATTENTION: AFTER THE 'mscw' STAGE, YOU MUST RUN 
# THE 'frogs' STAGE FOR THIS OPTION TO FULLY TAKE EFFECT
# yes/no
USEFROGS="yes"

# Where should the frogs's output files be stored?
FROGSDIR="$EVNDISPDIR/frogs"

# where should we put the anasum files (parallel and merged)?
# (full path please)
ANASUMOUTPUTDIR="$CWD/arf"

# what should we name the final merged anasum
# output root file? It will be put in $ANASUMOUTPUTDIR
FINALOUTPUT="anmer.output.root"

# which anasum runparameter file should we use?
# (full path please)
RUNPARAMFILE="$VERITAS_EVNDISP_AUX_DIR/ParameterFiles/ANASUM.runparameter.Crab.ctools"

# For the radial acceptance file, what date should be used
# in the radial acceptance filename?
# e.g. radialAcceptance-d20131115-cut-N3-Point-005CU-Soft-V5-T234.root
#                        ^^^^^^^^
# (all other parts of filename will be figured out automatically)
RADECDATE="20131115"

# for the mscw lookup tables, what date should be used in the filename?
# e.g. table_d20131115_GrIsuDec12_ATM22_V5_ID0
#             ^^^^^^^^
# (all other parts of filename will be figured out automatically)
TABLEDATE="20131115"

# for the gamma-hadron cut file, what date should be used in the filename?
# ANASUM.GammaHadron.d20130411-cut-N2-Point-005CU-Soft.dat
#                     ^^^^^^^^
# (all other parts of filename will be figured out automatically)
GAMHADCUTDATE="20130411"

# for the effective area file, what two dates should be used in the filename? 
# effArea-d????????-cut-N3-Point-005CU-Soft-ATM22-V5-T1234-d????????.root
#          ^EFDATE1                                         ^EFDATE2
# (all other parts of filename will be figured out automatically)
EFDATE1="20131031"
EFDATE2="20131115"

# Which directory should we keep the morphed ctools datafiles?
# used by (mutate) stage
CTOOLSDIR="$CWD/ctoolsdata"

#
# END ANALYSIS SETTINGS
#
###########################################################################################


BINNAME="$0"
if [[ $# < 1 || ! $1 =~ (evndisp|mscw|frogs|anpar|anmer|mutate|jobs|kill) ]] ; then 
    echo "
HOW DO I USE THIS ?                             
   1. Put this script in a new directory,                    
   2. Add your runlist file to that directory,        
   3. Edit the ANALYSIS SETTINGS within this file,
   4. Run commands:
        Run stages of the analysis:
        $ $BINNAME [evndisp|mscw|frogs|anpar|anmer|mutate]                
        See currently running jobs:
        $ $BINNAME jobs                                      
        Check the results of each stage for errors
        $ $BINNAME [evndisp|mscw|frogs|anpar|anmer|mutate] check"
	echo
    echo "Include a stage (evndisp, mscw, anpar, anmer) please, (optional 'check' afterwards)"
	echo " $ $BINNAME evndisp         # run the 'event display' stage"
	echo " $ $BINNAME evndisp check   # after evndisp, check its log and datafiles for problems"
	echo " $ $BINNAME mscw            # run the 'mean scaled width' stage"
	echo " $ $BINNAME mscw check      # after mscw, check its log and datafiles for problems"
	echo " $ $BINNAME frogs           # run the 'frogs image reconstruction' stage"
	echo " $ $BINNAME frogs check     # after frogs, check its log and datafiles for problems"
	echo " $ $BINNAME anpar           # run the 'anasum parallel' stage"
	echo " $ $BINNAME anpar check     # after anpar, check its log and datafiles for problems"
	echo " $ $BINNAME mutate          # after anpar, convert anasum parallel files to ctool's fits format"
	echo " $ $BINNAME mutate check    # after anpar, check the mutate stage's log and datafiles"
	echo " $ $BINNAME anmer           # merge the anasum parallel files to one anasum file"
	echo "Or, a command:"
	echo "  $ $BINNAME jobs   # show progress of all of this project's jobs, updating every 90 seconds, and block until jobs are done"
	echo "  $ $BINNAME kill   # halt all this project's jobs"
	echo ; exit 1
fi

exec 5>&1 # extra place to duplicate output to stdout, look for >&5

if [ ! -d "$EVNDISPSYS" ] ; then
	echo "error, \$EVNDISPSYS=$EVNDISPSYS isn't a valid directory, exiting..."
	exit 1
fi

if [ ! -e "$RUNLIST" ] ; then
	echo "error, \$RUNLIST=$RUNLIST needs to be a valid file, exiting..."
fi

# keyword to search log files for,
# any lines matching $DEBUGREGEX will be
# shown in blue when 'check'ing stages
# e.g. DEBUGREGEX="NKH|WHITEBOARD"
# will highlight any "NKH" or any "WHITEBOARD"
# that shows up in the log files.
# it is used as a Perl-style Regex, aka:
# grep -P $DEBUGREGEX logfilename
DEBUGREGEX="WHITEBOARD"

# if set to yes, some stages will only run
# for the first few hundred events
# to allow for very fast testing
export FASTDEVMODE=yes

# needed to transfer files from evndisp to mscw stage and to anpar stage

STAGE=$1
CHK=$2
if [ "$CHK" = "check" ] ; then
	CHECKFLAG=true
else
	CHECKFLAG=false
fi

# directory for storing information about stages, jobs, etc
SCIDIR="$CWD/.pipeline"
mkdir -p $SCIDIR

# extra functions
source $EVNDISPSYS/scripts/VTS/helper_scripts/pipeline_functions.sh

# frogs output directory
mkdir -p $FROGSDIR

# anasum output directory
mkdir -p $ANASUMOUTPUTDIR

# ctools output directory
mkdir -p $CTOOLSDIR

# alert the user if they are using FASTDEVMODE
function checkForFASTDEVMODE {
    if [ "$FASTDEVMODE" = "yes" ] ; then
        echo -e "${COTYELLOW}Warning, \$FASTDEVMODE=yes, not all events will be processed (this variable is set in ANALYSIS.pipeline)...${CONORM}"
    fi
}

STAGEFILE="$SCIDIR/stage"
RUNNINGJOBS="$SCIDIR/runningjobs" # file containing job numbers from the last action
if [[ "$1" == "jobs" ]] ; then # print run status
    checkIfJobsAreDone "$RUNNINGJOBS" "$STAGEFILE" 90
fi

if [[ "$1" == "kill" ]] ; then # kill all running jobs
    killJobsInJobfile "$RUNNINGJOBS"
fi


function setupFilteredRunlists {
	TABLEFILEWINTV4="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM21_V4_ID0"
	TABLEFILESUMMV4="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM22_V4_ID0"
	TABLEFILEWINTV5="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM21_V5_ID0"
	TABLEFILESUMMV5="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM22_V5_ID0"
	TABLEFILEWINTV6="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM21_V6_ID0"
	TABLEFILESUMMV6="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM22_V6_ID0"
	RUNLISTV4="$SCIDIR/runlist.V4"
	RUNLISTV5="$SCIDIR/runlist.V5"
	RUNLISTV6="$SCIDIR/runlist.V6"
	RUNLISTSUMMV4="$SCIDIR/runlist.summer.V4"
	RUNLISTWINTV4="$SCIDIR/runlist.winter.V4"
	RUNLISTSUMMV5="$SCIDIR/runlist.summer.V5"
	RUNLISTWINTV5="$SCIDIR/runlist.winter.V5"
	RUNLISTSUMMV6="$SCIDIR/runlist.summer.V6"
	RUNLISTWINTV6="$SCIDIR/runlist.winter.V6"
	cd $EVNDISPSYS/scripts/VTS
    RUNLIST.whichRunsAreArrayEpoch.sh 4 $RUNLIST > $RUNLISTV4
    RUNLIST.whichRunsAreArrayEpoch.sh 5 $RUNLIST > $RUNLISTV5
    RUNLIST.whichRunsAreArrayEpoch.sh 6 $RUNLIST > $RUNLISTV6
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 4 > $RUNLISTSUMMV4
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 4 > $RUNLISTWINTV4
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 5 > $RUNLISTSUMMV5
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 5 > $RUNLISTWINTV5
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 6 > $RUNLISTSUMMV6
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 6 > $RUNLISTWINTV6
	cd $CWD
}

# make list of run-specific parameter files
PARAMFILELIST="$SCIDIR/paramfilelist.dat"
ANASUMRUNLIST="$CWD/AnasumRunList.dat"
RUNNUMBERS=`cat $RUNLIST`
function makeParamFile {
    rm -rf $PARAMFILELIST
    rm -rf $ANASUMRUNLIST
    # generate basic param files
	$EVNDISPSYS/scripts/VTS/helper_scripts/pipeline_generateParamFiles.sh \
        "$CUTS"       "$GAMHADCUTDATE" "$RADECDATE" 20131031 20131115 "$TABLEDATE" 3      "$RUNLIST" > "$PARAMFILELIST"
	#   ^cutKeyWord    ^^GHCut           ^^RadAcc   ^^EF1    ^^EF2      ^^Table    ^NTel
    
    # now put these filenames in the AnasumRunList format
    # fill AnasumRunList with each run's info
    # GENERATE ANASUMRUNLIST
    #echo "" > $ANASUMRUNLIST
    rm -rf "$ANASUMRUNLIST"
	echo "Making Param File, using $BACKGROUND background method"
    for ARUN in $RUNNUMBERS ; do
        ARCUTSFILE=$(      grep "R$ARUN" "$PARAMFILELIST" | grep -oE "\S*ANASUM.GammaHadron\S*" )
        AREFFAREAFILE=$(   grep "R$ARUN" "$PARAMFILELIST" | grep -oE "\S*effArea\S*"            )
        ARRADIALACCFILE=$( grep "R$ARUN" "$PARAMFILELIST" | grep -oE "\S*radialAcceptance\S*"   ) 
        #ARRADIALACCFILE="imgselAcceptFile.root"
		if [[ $BACKGROUND == ring ]] ; then
            echo "* $ARUN $ARUN 0 $ARCUTSFILE 1 $AREFFAREAFILE $RINGCENT $RINGAREA $ARRADIALACCFILE" >> $ANASUMRUNLIST
		elif [[ $BACKGROUND == refl* ]] ; then
            echo "* $ARUN $ARUN 0 $ARCUTSFILE 2 $AREFFAREAFILE $REFLWOBOFF $REFLMINREG $REFLMAXREG $ARRADIALACCFILE" >> $ANASUMRUNLIST
		else
			echo -e "${COTRED}Error, unrecognized background keyword '$BACKGROUND', must be 'ring' or 'refl', exiting...${CONORM}"
			exit 1
        fi
    done
}


# take output from qsub commands, and parse it
# for job numbers, usually:
# Your job ##########
# and add it to the runningJobList
function updateRunningJobFile {
    local INPUTDATA="$1"
    local ACTIVEJOBS=$( echo "$QSUBDATA" | grep -oP "JOBID [0-9.-:]+" | awk '{print $2}' )
    rm -rf "$RUNNINGJOBS" ;
    for AJOB in $ACTIVEJOBS ; do
        #echo "updateRunningJobFile: Adding job: $AJOB"
        echo "$AJOB" >> $RUNNINGJOBS
    done
}


# s1 event display
if [[ "$STAGE" == "evndisp" ]] ; then
	EVNJOBSUB="$SCIDIR/qsubdata.evndisp"
	if ! $CHECKFLAG ; then 
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		makeParamFile
		# evndisp #########################################################
		echo -e "${COBLUE}Stage 1 : Event Reconstruction ${CONORM}"
		echo "$STAGE" > "$STAGEFILE"
        checkForFASTDEVMODE
		cd $EVNDISPSYS/scripts/VTS
        if [[ "$DOCALIB" = yes ]] ; then CALIBCODE=1
        else                             CALIBCODE=0 ; fi
		QSUBDATA=$(./ANALYSIS.evndisp.sh $RUNLIST $EVNDISPDIR $CALIBCODE | tee >(cat - >&5) )  ####### EVNDISP
		rm -rf "$EVNJOBSUB"
		echo "$QSUBDATA" > "$EVNJOBSUB"
		updateRunningJobFile "$QSUBDATA"
		
	else # check the stage results
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		# evndisp check #########################################################
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo "checking the evndisp stage" 
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" 
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$EVNJOBSUB" $DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$EVNJOBSUB"
        echo
        
		QSUBDATA=$(cat "$EVNJOBSUB")
		while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }')
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $DEBUGREGEX
            
            if [ "$DOCALIB" == "yes" ] ; then
                PEDLOG=$(   cat "$OLOG" | grep "RUN$ARUN PEDLOG"   | awk '{ print $3 }' )
                if filenameIsNotHealthy "$PEDLOG" "PEDLOG" "pedestal log file" "$OLOG"        ; then continue ; fi
                checkLogFileForProblems "$PEDLOG" $DEBUGREGEX
                
                TZEROLOG=$( cat "$OLOG" | grep "RUN$ARUN TZEROLOG" | awk '{ print $3 }' )
                if filenameIsNotHealthy "$TZEROLOG" "TZEROLOG" "tzero log file" "$OLOG"       ; then continue ; fi
                checkLogFileForProblems "$TZEROLOG" $DEBUGREGEX
            fi

            EVNDISPLOG=$(   cat "$OLOG" | grep "RUN$ARUN EVNDISPLOG" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$EVNDISPLOG" "EVNDISPLOG" "evndisp log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$EVNDISPLOG" $DEBUGREGEX
            
            checkLogFileForStageSuccess "$EVNDISPLOG" "Final checks on result file (seems to be OK):"
		done < $RUNLIST
		
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		OLOG=$( echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG" | head -n 1 | awk '{ print $4 }' )
        if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then echo -e "${COTRED}Error, Probably can't find datafiles, because we can't find the batch stdout log file...$CONORM" ; fi
        
		DFDIR=$( cat $OLOG | grep -P "^RUN\d{5} EVNDISPLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo -e "~~~~~~~~~~~ Evndisp Datafiles stored in $DFDIR/ $CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(    echo "$RUNDATA"  | grep -P "^RUN $ARUN OLOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then continue ; fi
            
			ELOG=$(    echo "$RUNDATA"  | grep -P "^RUN $ARUN ELOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG" | grep "RUN$ARUN EVNDISPDATA"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "EVNDISPDATA" "evndisp datafile" "$OLOG"   ; then continue ; fi
            
            if [ "$DOCALIB" == "yes" ] ; then
                PEDLOG=$(   cat "$OLOG" | grep "RUN$ARUN PEDLOG"   | awk '{ print $3 }' )
                if filenameIsNotHealthy "$PEDLOG" "PEDLOG" "pedestal log file"  "$OLOG" ; then continue ; fi
                
                TZEROLOG=$( cat "$OLOG" | grep "RUN$ARUN TZEROLOG" | awk '{ print $3 }' )
                if filenameIsNotHealthy "$TZEROLOG" "TZEROLOG" "tzero log file" "$OLOG" ; then continue ; fi
            fi
            
            EVNDISPLOG=$(   cat "$OLOG" | grep "RUN$ARUN EVNDISPLOG"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$EVNDISPLOG" "EVNDISPLOG" "evndisp log file" "$OLOG"  ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$EVNDISPLOG" )
            if [ "$DOCALIB" == "yes" ] ; then
                LOGFILES=( "$PEDLOG" "$TZEROLOG" )
            fi
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$EVNDISPLOG" "Final checks on result file (seems to be OK):")
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST

		exit

	fi
fi

# s2 mscw
if [[ "$STAGE" == "mscw" ]] ; then
	MSCWJOBSUB="$SCIDIR/qsubdata.mscw"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		# mscw #########################################################
		echo -e "${COBLUE}Stage 2 - Mean Scale Length/Width Calculation${CONORM}"
		#echo -e "Feeding files from $EVNDISPDIR"
		echo "$STAGE" > "$STAGEFILE"
        checkForFASTDEVMODE
		setupFilteredRunlists
		makeParamFile
		cd $EVNDISPSYS/scripts/VTS
		#./VTS.MSCW_ENERGY.sub_analyse_data.sh $TABLEFILE $EVNDISPDIR $RUNLIST
		QSUBDATA=""
		NRUNS=$( cat $RUNLISTWINTV4 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTWINTV4 $TABLEFILEWINTV4 $RECID "$EVNDISPDIR" "${EVNDISPDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV4 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTSUMMV4 $TABLEFILESUMMV4 $RECID "$EVNDISPDIR" "${EVNDISPDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTWINTV5 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTWINTV5 $TABLEFILEWINTV5 $RECID "$EVNDISPDIR" "${EVNDISPDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV5 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTSUMMV5 $TABLEFILESUMMV5 $RECID "$EVNDISPDIR" "${EVNDISPDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTWINTV6 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTWINTV6 $TABLEFILEWINTV6 $RECID "$EVNDISPDIR" "${EVNDISPDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV6 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTSUMMV6 $TABLEFILESUMMV6 $RECID "$EVNDISPDIR" "${EVNDISPDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		rm -rf "$MSCWJOBSUB"
		echo "$QSUBDATA" > "$MSCWJOBSUB"
		updateRunningJobFile "$QSUBDATA"
	else
		#haltIfAnyJobsAreRunning $RUNNINGJOBS
		# mscw check #########################################################
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo "checking the mscw stage" 
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$MSCWJOBSUB" $DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$MSCWJOBSUB"
        echo
        
		QSUBDATA=$(cat "$MSCWJOBSUB")
		while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$MSCWJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $DEBUGREGEX
            
            MSCWLOG=$(   cat "$OLOG" | grep "RUN$ARUN MSCWLOG"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$MSCWLOG" "MSCWLOG" "mscw log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$MSCWLOG" $DEBUGREGEX
            
            checkLogFileForStageSuccess "$MSCWLOG" "...outputfile closed"
		done < $RUNLIST

		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"    | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d{5} MSCWLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo
		echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ MSCW Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN OLOG"     | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$MSCWJOBSUB" ; then continue ; fi
            
			ELOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN ELOG"     | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$MSCWJOBSUB" ; then continue ; fi
            
            MSCWLOG=$(  cat "$OLOG"      | grep "RUN$ARUN MSCWLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$MSCWLOG"  "MSCWLOG"  "mscw log file" "$OLOG"   ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG"      | grep "RUN$ARUN MSCWDATA" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "MSCWDATA" "mscw datafile" "$OLOG"   ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$MSCWLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$MSCWLOG" "...outputfile closed" )
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST
	fi
fi

# s3 frogs 
if [[ "$STAGE" == "frogs" ]] ; then
    FROGSJOBSUB="$SCIDIR/qsubdata.frogs"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		echo -e "${COBLUE}Stage 3 - Frogs Image Reconstruction${CONORM}"
		echo "$STAGE" > "$STAGEFILE"
		cd $EVNDISPSYS/scripts/VTS
        checkForFASTDEVMODE
		setupFilteredRunlists
		makeParamFile
        
        # frogs ########################################################
		QSUBDATA=""
		NRUNS=$( cat $RUNLISTV4 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
            QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.evndisp_frogs.sh "$RUNLISTV4" "$FROGSDIR" "$EVNDISPDIR/RecID${RECID}" 0 | tee >(cat - >&5) ) ; fi
		NRUNS=$( cat $RUNLISTV5 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
            QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.evndisp_frogs.sh "$RUNLISTV5" "$FROGSDIR" "$EVNDISPDIR/RecID${RECID}" 0 | tee >(cat - >&5) ) ; fi
		NRUNS=$( cat $RUNLISTV6 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
            QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.evndisp_frogs.sh "$RUNLISTV6" "$FROGSDIR" "$EVNDISPDIR/RecID${RECID}" 0 | tee >(cat - >&5) ) ; fi
		updateRunningJobFile "$QSUBDATA"
		rm -rf "$FROGSJOBSUB"
        echo "$QSUBDATA" > "$FROGSJOBSUB"
        sleep 2
	else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		# frogs check #########################################################
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo "checking the frogs stage" 
        echo
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$FROGSJOBSUB" $DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$FROGSJOBSUB"
        
        # scan all log files
        QSUBDATA=$( cat $FROGSJOBSUB )
		while read ARUN ; do
            echo
			echo -e "${COBLUE}~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$FROGSJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$FROGSJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $DEBUGREGEX
            
            FROGSLOG=$( cat "$OLOG" | grep "RUN$ARUN FROGSLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$FROGSLOG" "FROGSLOG" "frogs log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$FROGSLOG" $DEBUGREGEX
            
            checkLogFileForStageSuccess "$FROGSLOG" "Final checks on result file (seems to be OK)"
		done < $RUNLIST

		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"     | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d+ FROGSLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo
		echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ FROGS Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN OLOG"      | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG"     "OLOG"      "$HUMANBATCHSTDOUT" "$FROGSJOBSUB" ; then continue ; fi
            
			ELOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN ELOG"      | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG"     "ELOG"      "$HUMANBATCHSTDERR" "$FROGSJOBSUB" ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG"      | grep "RUN$ARUN FROGSDATA" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "FROGSDATA" "frogs datafile"    "$OLOG"        ; then continue ; fi
            
            FROGSLOG=$( cat "$OLOG"      | grep "RUN$ARUN FROGSLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$FROGSLOG" "FROGSLOG"  "frogs log file"    "$OLOG"        ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$FROGSLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$FROGSLOG" "Final checks on result file (seems to be OK)" )
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST
	fi
fi

# s4 anasum_parallel (anpar)
if [[ "$STAGE" == "anpar" ]] ; then
	ANPARJOBSUB="$SCIDIR/qsubdata.anpar"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		makeParamFile
		# anpar #########################################################
		echo -e "${COBLUE}Stage 4 - Anasum Parallel${CONORM}"
		echo "$STAGE" > "$STAGEFILE"
        checkForFASTDEVMODE
		cd $EVNDISPSYS/scripts/VTS
		#./VTS.ANASUM.sub_analyseParallel_data.sh $ANASUMRUNLIST $VERITAS_USER_DATA_DIR/analysis/EVD400-d20121218/RecID0 $ANASUMOUTPUTDIR $RUNPARAMFILE
		#QSUBDATA=$( ./VTS.ANASUM.sub_analyseParallel_data.sh $ANASUMRUNLIST $EVNDISPDIR/RecID0 $ANASUMOUTPUTDIR $RUNPARAMFILE | tee >(cat - >&5) )
        if [[ "$USEFROGS" == "yes" ]] ; then 
            INPUTANASUMDIR="$FROGSDIR"
            echo -e "${COTYELLOW}Using frogs files as input...$CONORM"
        else
            INPUTANASUMDIR="$EVNDISPDIR/RecID${RECID}"
            echo -e "Using mscw files as input..."
        fi
		QSUBDATA=$( ./ANALYSIS.anasum_parallel.sh "$ANASUMRUNLIST" "$ANASUMOUTPUTDIR" "$RUNPARAMFILE" "$INPUTANASUMDIR" | tee >(cat - >&5) )
		updateRunningJobFile "$QSUBDATA"
		rm -rf "$ANPARJOBSUB"
        echo "$QSUBDATA" > "$ANPARJOBSUB"
        sleep 2
	else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		# anpar check #########################################################
		echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" ; echo "checking the anpar stage" 
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$ANPARJOBSUB" $DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$ANPARJOBSUB"
        echo
        
		QSUBDATA=$( cat $ANPARJOBSUB )
		for ARUN in $RUNNUMBERS ; do # check batch and log files
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$( echo "$RUNDATA" | grep "RUN $ARUN OLOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$ANPARJOBSUB" ; then continue ; fi
			checkLogFileForProblems "$OLOG" $DEBUGREGEX
            
			ELOG=$( echo "$RUNDATA" | grep "RUN $ARUN ELOG" | awk '{ print $4 }' )
			checkLogFileForProblems "$ELOG" $DEBUGREGEX
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$ANPARJOBSUB" ; then continue ; fi
            
            ANPARLOG=$( cat "$OLOG" | grep "RUN$ARUN ANPARLOG" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$ANPARLOG" "ANPARLOG" "anasum parallel log file" "$OLOG" ; then continue ; fi
            checkLogFileForProblems "$ANPARLOG" $DEBUGREGEX
             
            checkLogFileForStageSuccess "$ANPARLOG" "analysis results written to"
		done < $RUNLIST
		
		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"     | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d{5} ANPARLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ ANASUM Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$ANPARJOBSUB"        ; then continue ; fi
            
            ANPARLOG=$(  cat "$OLOG" | grep "RUN$ARUN ANPARLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$ANPARLOG" "ANPARLOG" "anasum parallel log file" "$OLOG"  ; then continue ; fi
            
            DATAFILE=$(  cat "$OLOG" | grep "RUN$ARUN ANPARDATA"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "ANPARDATA" "anasum parallel datafile" "$OLOG"   ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$ANPARLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            RUNSIGMA=$( grep -E "ALL RUNS" "$ANPARLOG" | grep -oP '\d{1,3}\.\d{0,2} sigma' | grep -oP '\d{1,3}\.\d{0,2}')
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$ANPARLOG" "analysis results written to" )
            printf "%10s is %s, last modified %19s sigma=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$RUNSIGMA" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
            
		done < $RUNLIST

	fi
fi

# s5 anasum
if [[ "$STAGE" == "anmer" ]] ; then
	FINALOUTPUTLOG="${ANASUMOUTPUTDIR}/`basename $FINALOUTPUT .root`.log"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		makeParamFile
		echo -e "${COBLUE}Stage 5a - Anasum Merge${CONORM}"
		echo "$STAGE" > "$STAGEFILE"
		#cd $EVNDISPSYS/bin
		#nice -n 19 ./anasum -d $ANASUMOUTPUTDIR -l $ANASUMRUNLIST -i 1 -f $RUNPARAMFILE -o $FINALOUTPUT 2>&1 | tee "$FINALOUTPUTLOG"
		cd $EVNDISPSYS/scripts/VTS
		nice -n 19 ./ANALYSIS.anasum_combine.sh $ANASUMRUNLIST $ANASUMOUTPUTDIR $FINALOUTPUT $RUNPARAMFILE | tee "$FINALOUTPUTLOG"
		updateRunningJobFile ""
     
    else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		# check the stage results
		echo "Checking the anmer stage"
        if filenameIsNotHealthy "$FINALOUTPUTLOG" "(filename constructed in ANALYSIS.pipeline)" "merged anasum log file" "ANALYSIS.pipeline"  ; then continue ; fi
		checkLogFileForProblems $FINALOUTPUTLOG $DEBUGREGEX
        
		DATAFILE="${ANASUMOUTPUTDIR}/${FINALOUTPUT}"
        if filenameIsNotHealthy "$DATAFILE" "FINALOUTPUT" "merge anasum datafile" "ANALYSIS.pipeline"  ; then continue ; fi
        
        LOGFILES=( "$FINALOUTPUTLOG" )
        WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
        ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
        RUNSIGMA=$( grep -E "ALL RUNS" "$FINALOUTPUTLOG" | grep -oP '\d{1,3}\.\d{0,2} sigma' | grep -oP '\d{1,3}\.\d{0,2}')
        
        DFBASE=$( basename $DATAFILE )
        DFSIZE=`stat -c %s $DATAFILE`
        DFSIZESTR=$( formatFileSize "$DFSIZE" )
        DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
        printf "%10s is %s, last modified %19s sigma=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$RUNSIGMA" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
	fi
fi

# s6 mutate
if [[ "$STAGE" == "mutate" ]] ; then
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		echo -e "${COBLUE}Stage 5b - Mutate (convert) Anasum Parallel files to CTOOL's Data Format${CONORM}"
        
        cd $EVNDISPSYS/bin
        echo "now here: $PWD"
        echo "output data going here: $CTOOLSDIR"
        while read ARUN ; do
            # this stage runs quite fast (~10seconds per run)
            # so we wont run it in parallel
            #echo "$ANASUMOUTPUTDIR/$ARUN.anasum.root"
            echo "Producing $CTOOLSDIR/$ARUN.ctools.fits ..."
            writeCTAEventListFromAnasum -f -i "$ANASUMOUTPUTDIR/$ARUN.anasum.root" -o "$CTOOLSDIR/$ARUN.ctools.fits" >  "$CTOOLSDIR/$ARUN.ctools.log" 2>&1  
            #echo
        done < $RUNLIST
        
    else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		# check the stage results
		echo "Checking the mutate stage"
        
        # check log files
        while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
            CTOOLSLOG="$CTOOLSDIR/$ARUN.ctools.log"
            checkLogFileForProblems     "$CTOOLSLOG" $DEBUGREGEX
            checkLogFileForStageSuccess "$CTOOLSLOG" "Conversion from .* complete"
        done < $RUNLIST
        
        # check data files
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ CTOOLS Datafiles stored in $CTOOLSDIR/$CONORM"
        while read ARUN ; do
            LOGFILES=("$CTOOLSDIR/$ARUN.ctools.log" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DATAFILE="$CTOOLSDIR/$ARUN.ctools.fits"
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            NEVENTS=$( cat "$CTOOLSDIR/$ARUN.ctools.log" | grep -P "RunNumber \d+, \d+ events written." | grep -oP ", \d+ events" | grep -oP "\d+" )
            RUNSUCCESS=$( checkForSuccess "$CTOOLSDIR/$ARUN.ctools.log" "Conversion from .* complete" )
            printf "%10s is %s, last modified %19s events=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$NEVENTS" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
        done < $RUNLIST
    fi
fi
