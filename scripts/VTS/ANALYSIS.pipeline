#!/bin/bash
CWD=$PWD
########################################
#
# Written by Nathan Kelley-Hoskins
# Feb 2013
#

########################################################
# HOW DO I USE THIS ?                                  #
# put this in a new directory,                         #
# add your runlist file to that directory,             #
# edit the settings below, then use the commands       #
# $ ANALYSIS.pipeline [evndisp|mscw|anpar|anmer]       #
# to run stages of the analysis,                       #
# $ ANALYSIS.pipeline jobs                             #
# to see currently running jobs, and                   #
# $ ANALYSIS.pipeline [evndisp|mscw|anpar|anmer] check #
# to check the results of each stage for errors        #
########################################################

#############################################################################
#
# ANALYSIS SETTINGS:
#

# OPTIONAL: Which event display installation do you want to use?
# if you leave this commented out, you must have EVNDISPSYS defined ($ echo "$EVNDISPSYS" )
# (full path please)
#export EVNDISPSYS="/afs/ifh.de/user/n/nkelhos/scratch/VERITAS/EVNDISP/EVNDISP-400/trunk"

# Which runlist do you want to use?
# It should be a simple list of veritas runnumbers,
# one per line.
# (full path please)
RUNLIST="$CWD/runlist.crab.dat"

## use Model3D (yes/no)##
USEMODEL3D="no"

# What kind of cuts do you want to use?
# Currently supports 'soft', 'moderate', or 'hard'
CUTS="moderate"

# What kind of background do you want to use?
# 'ring' or 'refl' (for reflected)
BACKGROUND="refl" # ring or [refl, reflect, reflected]

# IF USING 'ring' BACKGROUND:
# how how big should the radius of the the 'on' region be, in degrees?
RINGCENT="0.5"
# and how big should the 'off' ring be, in units of 'on'-region areas?
RINGAREA="10"

# IF USING 'refl' BACKGROUND:
# what should be the minimum distance between off region edges, in degrees?
REFLWOBOFF="0.5"
# whats the minimum number of off regions we should use?
REFLMINREG="1"
# and the maximum number of off regions to use?
REFLMAXREG="10"

# Should we produce the tzero and pedestal files first?
# These are required to do an analysis.
# yes/no
DOCALIB=yes

# Where should we store the evndisp and mscw output files?
# (full path please)
# evndisp files will be: $EVNDISPOUTPUTDIR/#####.root, #####.tzero.root, etc
# mscw files will be put in RecIDX within this directory (see next option)
EVNDISPOUTPUTDIR="$VERITAS_USER_DATA_DIR/analysis/Results/EVD-v423/"

# Which Reconstruction ID (RecID) should we use?
# 0, 1, 2, 3, or 4
# 0 = do mscw stage with all available images
# 1 = do mscw stage without using T1 images
# 2 = do mscw stage without using T2 images
# 3 = do mscw stage without using T3 images
# 4 = do mscw stage without using T4 images
# For regular data analysis, this should be 0
RECID=0

# In the anasum stage, should we use frogs datafiles as the input?
# If no, we will use the mscw datafiles instead.
# To create the frogs datafiles, just run the 'frogs' stage.
# ATTENTION: AFTER THE 'mscw' STAGE, YOU MUST RUN 
# THE 'frogs' STAGE FOR THIS OPTION TO FULLY TAKE EFFECT
# yes/no
USEFROGS="yes"

# Where should the frogs's output files be stored?
FROGSOUTPUTDIR="$EVNDISPOUTPUTDIR/frogs"

# Where should we put the anasum output files (parallel and merged)?
# (full path please)
ANASUMOUTPUTDIR="$CWD/arf"

# What should we name the final merged anasum
# output root file? It will be put in $ANASUMOUTPUTDIR
FINALOUTPUT="anmer.output.root"

# Which anasum runparameter file should we use?
# (full path please)
RUNPARAMFILE="$VERITAS_EVNDISP_AUX_DIR/ParameterFiles/ANASUM.runparameter.Crab.ctools"

# For the radial acceptance file, what date should be used
# in the radial acceptance filename?
# e.g. radialAcceptance-d20131115-cut-N3-Point-005CU-Soft-V5-T234.root
#                        ^^^^^^^^
# (all other parts of filename will be figured out automatically)
# format: YYYYMMDD
RADECDATE="20131115"

# For the mscw lookup tables, what date should be used in the filename?
# e.g. table_d20131115_GrIsuDec12_ATM22_V5_ID0
#             ^^^^^^^^
# (all other parts of filename will be figured out automatically)
# format: YYYYMMDD
TABLEDATE="20131115"

# For the gamma-hadron cut file, what date should be used in the filename?
# ANASUM.GammaHadron.d20130411-cut-N2-Point-005CU-Soft.dat
#                     ^^^^^^^^
# (all other parts of filename will be figured out automatically)
# format: YYYYMMDD
#GAMHADCUTDATE="20130411"
GAMHADCUTDATE="20131031"

# For the effective area file, what two dates should be used in the filename? 
# effArea-d20131031-cut-N3-Point-005CU-Soft-ATM22-V5-T1234-d20131115.root
#          ^EFDATE1                                         ^EFDATE2
# (all other parts of filename will be figured out automatically)
# format: YYYYMMDD
EFDATE1="20131031"
EFDATE2="20131115"

# Which directory should we keep the morphed ctools datafiles?
# used by (mutate) stage
CTOOLSDIR="$CWD/ctoolsdata"

# Should we use manually-defined laser runs for some runs?
# (yes/no)
SCIPIPE_MANUALLASER="yes"
# If yes, which calibration file should we use to manually define 
# which runs have which laser runs?
# The calibration file should be in $VERITAS_EVNDISP_AUX_DIR/Calibration ,
# and should have the same format as calibrationlist.dat in that directory.
SCIPIPE_MANUALLASERFILE="calibrationlist.dat"

#
# END ANALYSIS SETTINGS
#
###########################################################################################


BINNAME="$0"
if [[ $# < 1 || ! $1 =~ (evndisp|mscw|frogs|anpar|anmer|mutate|jobs|kill) ]] ; then 
    echo "
HOW DO I USE THIS ?                             
   1. Copy this script into a new directory,                    
   2. Add your runlist file to that directory,        
   3. Edit the ANALYSIS SETTINGS within your copied ANALYSIS.pipeline file,
   4. Run a stage of the analysis:
		
        i) Submit stage jobs to the cluster:
        $ $BINNAME [evndisp|mscw|frogs|anpar|anmer|mutate]                
		
        ii) Check if jobs are done:
        $ $BINNAME jobs
		
        iii) Check the results of the stage for errors
        $ $BINNAME [evndisp|mscw|frogs|anpar|anmer|mutate] check
		
Stages of Event Display: (evndisp, mscw, frogs, anpar, anmer) please,
  (optional 'check' afterwards)
  $ $BINNAME evndisp         # run the 'event display' stage
  $ $BINNAME evndisp check   # after evndisp, check its log and datafiles for problems
  $ $BINNAME mscw            # run the 'mean scaled width' stage
  $ $BINNAME mscw check      # after mscw, check its log and datafiles for problems
  $ $BINNAME frogs           # run the 'frogs image reconstruction' stage
  $ $BINNAME frogs check     # after frogs, check its log and datafiles for problems
  $ $BINNAME anpar           # run the 'anasum parallel' stage
  $ $BINNAME anpar check     # after anpar, check its log and datafiles for problems
  $ $BINNAME mutate          # after anpar, convert anasum parallel files to ctool's fits format
  $ $BINNAME mutate check    # after anpar, check the mutate stage's log and datafiles
  $ $BINNAME anmer           # after anpar, merge the anasum parallel files to one anasum file
Other commands:
  $ $BINNAME jobs   # show progress of all of this project's jobs, updating every 90 seconds, until all jobs are done
  $ $BINNAME kill   # halt all of this project's jobs
"
	exit 1
fi

exec 5>&1 # extra place to duplicate output to stdout, look for >&5

if [ ! -d "$EVNDISPSYS" ] ; then
	echo "error, \$EVNDISPSYS=$EVNDISPSYS isn't a valid directory, exiting..."
	exit 1
fi

if [ ! -e "$RUNLIST" ] ; then
	echo "error, \$RUNLIST=$RUNLIST needs to be a valid file, exiting..."
fi

# keyword to search log files for,
# any lines matching $DEBUGREGEX will be
# shown in blue when 'check'ing stages
# e.g. DEBUGREGEX="NKH|WHITEBOARD"
# will highlight any "NKH" or any "WHITEBOARD"
# that shows up in the log files.
# it is used as a Perl-style Regex, aka:
# grep -P $DEBUGREGEX logfilename
DEBUGREGEX="WHITEBOARD"

# if set to yes, some stages will only run
# for the first few hundred events
# to allow for very fast testing
export FASTDEVMODE=no

# settings file, any settings in this file will override the above settings
SETTINGSFILE="analysis.config"
if [ -f "$SETTINGSFILE" ] ; then
	echo "Loading settings from settings file '$SETTINGSFILE'..."
	source "$SETTINGSFILE"
fi

# needed to transfer files from evndisp to mscw stage and to anpar stage

STAGE=$1
CHK=$2
if [ "$CHK" = "check" ] ; then
	CHECKFLAG=true
else
	CHECKFLAG=false
fi

# directory for storing information about stages, jobs, etc
SCIDIR="$CWD/.pipeline"
mkdir -p $SCIDIR

# extra functions
source $EVNDISPSYS/scripts/VTS/helper_scripts/pipeline_functions.sh

# evndisp output directory
mkdir -p $EVNDISPOUTPUTDIR

# frogs output directory
mkdir -p $FROGSOUTPUTDIR

# anasum output directory
mkdir -p $ANASUMOUTPUTDIR

# ctools output directory
mkdir -p $CTOOLSDIR

# check that $SCIPIPE_MANUALLASERFILE is a valid
# file in $VERITAS_EVNDISP_AUX_DIR/Calibration
if [[ "$SCIPIPE_MANUALLASER" == "yes" ]] ; then
	if [[ ! -f "$SCIPIPE_MANUALLASERFILE" ]] ; then
		echo "Error, you specified 'SCIPIPE_MANUALLASER=yes', but the file specified by 'SCIPIPE_MANUALLASERFILE=$SCIPIPE_MANUALLASERFILE' doesn't seem to exist.  Use 'SCIPIPE_MANUALLASER=no', or figure out the right file for SCIPIPE_MANUALLASERFILE, exiting..."
		exit 1
	fi
fi

# alert the user if they are using FASTDEVMODE
function checkForFASTDEVMODE {
    if [ "$FASTDEVMODE" = "yes" ] ; then
        echo -e "${COTYELLOW}Warning, \$FASTDEVMODE=yes, not all events will be processed (this variable is set in ANALYSIS.pipeline)...${CONORM}"
    fi
}

STAGEFILE="$SCIDIR/stage"
RUNNINGJOBS="$SCIDIR/runningjobs" # file containing job numbers from the last action
if [[ "$1" == "jobs" ]] ; then # print run status
    checkIfJobsAreDone "$RUNNINGJOBS" "$STAGEFILE" 90
fi

if [[ "$1" == "kill" ]] ; then # kill all running jobs
    killJobsInJobfile "$RUNNINGJOBS"
fi


function setupFilteredRunlists {
	TABLEFILEWINTV4="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM21_V4_ID0"
	TABLEFILESUMMV4="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM22_V4_ID0"
	TABLEFILEWINTV5="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM21_V5_ID0"
	TABLEFILESUMMV5="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM22_V5_ID0"
	TABLEFILEWINTV6="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM21_V6_ID0"
	TABLEFILESUMMV6="$VERITAS_EVNDISP_AUX_DIR/Tables/table_d${TABLEDATE}_GrIsuDec12_ATM22_V6_ID0"
	RUNLISTSUMMV4="$SCIDIR/runlist.summer.V4"
	RUNLISTWINTV4="$SCIDIR/runlist.winter.V4"
	RUNLISTSUMMV5="$SCIDIR/runlist.summer.V5"
	RUNLISTWINTV5="$SCIDIR/runlist.winter.V5"
	RUNLISTSUMMV6="$SCIDIR/runlist.summer.V6"
	RUNLISTWINTV6="$SCIDIR/runlist.winter.V6"
	cd $EVNDISPSYS/scripts/VTS
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 4 > $RUNLISTSUMMV4
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 4 > $RUNLISTWINTV4
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 5 > $RUNLISTSUMMV5
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 5 > $RUNLISTWINTV5
	RUNLIST.whichRunsAreAtmosphere.sh s $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 6 > $RUNLISTSUMMV6
	RUNLIST.whichRunsAreAtmosphere.sh w $RUNLIST | RUNLIST.whichRunsAreArrayEpoch.sh 6 > $RUNLISTWINTV6
	cd $CWD
}

# make list of run-specific parameter files
PARAMFILELIST="$SCIDIR/paramfilelist.dat"
ANASUMRUNLIST="$CWD/AnasumRunList.dat"
RUNNUMBERS=`cat $RUNLIST`
function makeParamFile {
    rm -rf $PARAMFILELIST
    rm -rf $ANASUMRUNLIST
    # generate basic param files
	$EVNDISPSYS/scripts/VTS/helper_scripts/pipeline_generateParamFiles.sh "$CUTS" "$GAMHADCUTDATE" "$RADECDATE" "$EFDATE1" "$EFDATE2" "$TABLEDATE" 3 "$USEFROGS" "$RUNLIST" > "$PARAMFILELIST"
	PARAMEXIT="$?"
	#echo "PARAMEXIT:$PARAMEXIT" # =0 if ok, !=0 if bad things happened
	if [[ "$PARAMEXIT" != "0" ]] ; then # had a problem generating param files
		echoerr "${COTRED}Error, had a problem generating parameter files (see above text), exiting pipeline...$CONORM"
		exit 1
	fi
    
    # now put these filenames in the AnasumRunList format
    # fill AnasumRunList with each run's info
    # GENERATE ANASUMRUNLIST
    #echo "" > $ANASUMRUNLIST
    rm -rf "$ANASUMRUNLIST"
	echo "Making Param File, using $BACKGROUND background method"
    for ARUN in $RUNNUMBERS ; do
        ARCUTSFILE=$(      grep "RUN$ARUN" "$PARAMFILELIST" | grep -oE "\S*ANASUM.GammaHadron\S*" )
        AREFFAREAFILE=$(   grep "RUN$ARUN" "$PARAMFILELIST" | grep -oE "\S*effArea\S*"            )
        ARRADIALACCFILE=$( grep "RUN$ARUN" "$PARAMFILELIST" | grep -oE "\S*radialAcceptance\S*"   ) 
		if [[ -z "$ARCUTSFILE" || -z "$AREFFAREAFILE" || -z "$ARRADIALACCFILE" ]] ; then
			echo -e "${COTRED}Error, couldn't determine an IRF file for Run $ARUN :"
			if [[ -z "$ARCUTSFILE"      ]] ; then echo -e "${COTRED}   GammaHadronCut   File:'$ARCUTSFILE'      $CONORM" ; fi
			if [[ -z "$AREFFAREAFILE"   ]] ; then echo -e "${COTRED}   EffectiveArea    File:'$AREFFAREAFILE'   $CONORM" ; fi
			if [[ -z "$ARRADIALACCFILE" ]] ; then echo -e "${COTRED}   RadialAcceptance File:'$ARRADIALACCFILE' $CONORM" ; fi
			exit 1
		fi

        #ARRADIALACCFILE="imgselAcceptFile.root"
		if [[ $BACKGROUND == ring ]] ; then
            echo "* $ARUN $ARUN 0 $ARCUTSFILE 1 $AREFFAREAFILE $RINGCENT $RINGAREA $ARRADIALACCFILE" >> $ANASUMRUNLIST
		elif [[ $BACKGROUND == refl* ]] ; then
            echo "* $ARUN $ARUN 0 $ARCUTSFILE 2 $AREFFAREAFILE $REFLWOBOFF $REFLMINREG $REFLMAXREG $ARRADIALACCFILE" >> $ANASUMRUNLIST
		else
			echo -e "${COTRED}Error, unrecognized background keyword '$BACKGROUND', must be 'ring' or 'refl', exiting...${CONORM}"
			exit 1
        fi
    done
}


# take output from qsub commands, and parse it
# for job numbers, usually:
# Your job ##########
# and add it to the runningJobList
function updateRunningJobFile {
    local INPUTDATA="$1"
    local ACTIVEJOBS=$( echo "$QSUBDATA" | grep -oP "JOBID [0-9.-:]+" | awk '{print $2}' )
    rm -rf "$RUNNINGJOBS" ;
    for AJOB in $ACTIVEJOBS ; do
        #echo "updateRunningJobFile: Adding job: $AJOB"
        echo "$AJOB" >> $RUNNINGJOBS
    done
}

function stageBanner {
	if $CHECKFLAG ; then
		BANNER="Checking the $STAGE Stage ~~~~~~~~~~~"
	else
		BANNER="Running the $STAGE Stage ~~~~~~~~~~~~"
	fi
	echo -e "${COTBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$CONORM"
	echo -e "${COTBLUE}~~~~ $BANNER$CONORM"
	echo -e "${COTBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$CONORM"
}


# s1 event display
if [[ "$STAGE" == "evndisp" ]] ; then
	EVNJOBSUB="$SCIDIR/qsubdata.evndisp"
	if ! $CHECKFLAG ; then 
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# evndisp #########################################################
		echo "$STAGE" > "$STAGEFILE"
		makeParamFile
        checkForFASTDEVMODE
		cd $EVNDISPSYS/scripts/VTS
        if [[ "$DOCALIB" = yes ]] ; then CALIBCODE=1
        else                             CALIBCODE=0 ; fi
        VPM=1 ## on by default
        if [[ "$USEMODEL3D" == "yes" ]] ; then MODEL3D=1
        else                                   MODEL3D=0 ; fi
                QSUBDATA=$(./ANALYSIS.evndisp.sh $RUNLIST $EVNDISPOUTPUTDIR $CALIBCODE $VPM $MODEL3D | tee >(cat - >&5) )
		rm -rf "$EVNJOBSUB"
		echo "$QSUBDATA" > "$EVNJOBSUB"
		updateRunningJobFile "$QSUBDATA"
		
	else # check the stage results
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# evndisp check #########################################################
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$EVNJOBSUB" $DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$EVNJOBSUB" "$RUNLIST"
        echo
        
		QSUBDATA=$(cat "$EVNJOBSUB")
		while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }')
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $DEBUGREGEX
            
            if [ "$DOCALIB" == "yes" ] ; then
                PEDLOG=$(   cat "$OLOG" | grep "RUN$ARUN PEDLOG"   | awk '{ print $3 }' )
                if filenameIsNotHealthy "$PEDLOG" "PEDLOG" "pedestal log file" "$OLOG"        ; then continue ; fi
                checkLogFileForProblems "$PEDLOG" $DEBUGREGEX
                
                TZEROLOG=$( cat "$OLOG" | grep "RUN$ARUN TZEROLOG" | awk '{ print $3 }' )
                if filenameIsNotHealthy "$TZEROLOG" "TZEROLOG" "tzero log file" "$OLOG"       ; then continue ; fi
                checkLogFileForProblems "$TZEROLOG" $DEBUGREGEX
            fi

            EVNDISPLOG=$(   cat "$OLOG" | grep "RUN$ARUN EVNDISPLOG" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$EVNDISPLOG" "EVNDISPLOG" "evndisp log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$EVNDISPLOG" $DEBUGREGEX
            
            checkLogFileForStageSuccess "$EVNDISPLOG" "Final checks on result file (seems to be OK):"
		done < $RUNLIST
		
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		OLOG=$( echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG" | head -n 1 | awk '{ print $4 }' )
        if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then echo -e "${COTRED}Error, Probably can't find datafiles, because we can't find the batch stdout log file...$CONORM" ; fi
        
		DFDIR=$( cat $OLOG | grep -P "^RUN\d{5} EVNDISPLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo -e "~~~~~~~~~~~ Evndisp Datafiles stored in $DFDIR/ $CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(    echo "$RUNDATA"  | grep -P "^RUN $ARUN OLOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$EVNJOBSUB"        ; then continue ; fi
            
			ELOG=$(    echo "$RUNDATA"  | grep -P "^RUN $ARUN ELOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG" | grep "RUN$ARUN EVNDISPDATA"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "EVNDISPDATA" "evndisp datafile" "$OLOG"   ; then continue ; fi
            
            if [ "$DOCALIB" == "yes" ] ; then
                PEDLOG=$(   cat "$OLOG" | grep "RUN$ARUN PEDLOG"   | awk '{ print $3 }' )
                if filenameIsNotHealthy "$PEDLOG" "PEDLOG" "pedestal log file"  "$OLOG" ; then continue ; fi
                
                TZEROLOG=$( cat "$OLOG" | grep "RUN$ARUN TZEROLOG" | awk '{ print $3 }' )
                if filenameIsNotHealthy "$TZEROLOG" "TZEROLOG" "tzero log file" "$OLOG" ; then continue ; fi
            fi
            
            EVNDISPLOG=$(   cat "$OLOG" | grep "RUN$ARUN EVNDISPLOG"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$EVNDISPLOG" "EVNDISPLOG" "evndisp log file" "$OLOG"  ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$EVNDISPLOG" )
            if [ "$DOCALIB" == "yes" ] ; then
                LOGFILES=( "$PEDLOG" "$TZEROLOG" )
            fi
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$EVNDISPLOG" "Final checks on result file (seems to be OK):")
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST

		exit

	fi
fi

# s2 mscw
if [[ "$STAGE" == "mscw" ]] ; then
	MSCWJOBSUB="$SCIDIR/qsubdata.mscw"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# mscw #########################################################
		echo "$STAGE" > "$STAGEFILE"
        checkForFASTDEVMODE
		setupFilteredRunlists
		makeParamFile
		cd $EVNDISPSYS/scripts/VTS
		#./VTS.MSCW_ENERGY.sub_analyse_data.sh $TABLEFILE $EVNDISPOUTPUTDIR $RUNLIST
		QSUBDATA=""
		NRUNS=$( cat $RUNLISTWINTV4 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTWINTV4 $TABLEFILEWINTV4 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV4 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTSUMMV4 $TABLEFILESUMMV4 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTWINTV5 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTWINTV5 $TABLEFILEWINTV5 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV5 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTSUMMV5 $TABLEFILESUMMV5 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTWINTV6 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTWINTV6 $TABLEFILEWINTV6 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		NRUNS=$( cat $RUNLISTSUMMV6 | wc -l )
		if [ "$NRUNS" -gt "0" ] ; then
			QSUBDATA="$QSUBDATA \n"$( ./ANALYSIS.mscw_energy.sh $RUNLISTSUMMV6 $TABLEFILESUMMV6 "$EVNDISPOUTPUTDIR" $RECID "${EVNDISPOUTPUTDIR}/RecID${RECID}" | tee >(cat ->&5) ) ; fi
		rm -rf "$MSCWJOBSUB"
		echo "$QSUBDATA" > "$MSCWJOBSUB"
		updateRunningJobFile "$QSUBDATA"
	else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# mscw check #########################################################
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$MSCWJOBSUB" $DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$MSCWJOBSUB" "$RUNLIST"
        echo
        
		QSUBDATA=$(cat "$MSCWJOBSUB")
		while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$MSCWJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$EVNJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $DEBUGREGEX
            
            MSCWLOG=$(   cat "$OLOG" | grep "RUN$ARUN MSCWLOG"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$MSCWLOG" "MSCWLOG" "mscw log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$MSCWLOG" $DEBUGREGEX
            
            checkLogFileForStageSuccess "$MSCWLOG" "...outputfile closed"
		done < $RUNLIST

		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"    | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d{5} MSCWLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo
		echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ MSCW Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN OLOG"     | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$MSCWJOBSUB" ; then continue ; fi
            
			ELOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN ELOG"     | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$MSCWJOBSUB" ; then continue ; fi
            
            MSCWLOG=$(  cat "$OLOG"      | grep "RUN$ARUN MSCWLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$MSCWLOG"  "MSCWLOG"  "mscw log file" "$OLOG"   ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG"      | grep "RUN$ARUN MSCWDATA" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "MSCWDATA" "mscw datafile" "$OLOG"   ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$MSCWLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$MSCWLOG" "...outputfile closed" )
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST
	fi
fi

# s3 frogs 
if [[ "$STAGE" == "frogs" ]] ; then
    FROGSJOBSUB="$SCIDIR/qsubdata.frogs"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# frogs #################################################################
		echo "$STAGE" > "$STAGEFILE"
		cd $EVNDISPSYS/scripts/VTS
        checkForFASTDEVMODE
		setupFilteredRunlists
		makeParamFile
        
        # frogs ########################################################
		QSUBDATA=$( ./ANALYSIS.evndisp_frogs.sh "$RUNLIST" "$FROGSOUTPUTDIR" "$EVNDISPOUTPUTDIR/RecID${RECID}" 0 | tee >(cat - >&5) )
		
		updateRunningJobFile "$QSUBDATA"
		rm -rf "$FROGSJOBSUB"
        echo "$QSUBDATA" > "$FROGSJOBSUB"
        sleep 2
	else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# frogs check #########################################################
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$FROGSJOBSUB" $DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$FROGSJOBSUB" "$RUNLIST"
        
        # scan all log files
        QSUBDATA=$( cat $FROGSJOBSUB )
		while read ARUN ; do
            echo
			echo -e "${COBLUE}~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$FROGSJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$OLOG" $DEBUGREGEX
            
			ELOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN ELOG"   | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$FROGSJOBSUB"        ; then continue ; fi
			checkLogFileForProblems "$ELOG" $DEBUGREGEX
            
            FROGSLOG=$( cat "$OLOG" | grep "RUN$ARUN FROGSLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$FROGSLOG" "FROGSLOG" "frogs log file" "$OLOG"  ; then continue ; fi
            checkLogFileForProblems "$FROGSLOG" $DEBUGREGEX
            
            checkLogFileForStageSuccess "$FROGSLOG" "Final checks on result file (seems to be OK)"
		done < $RUNLIST

		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"     | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d+ FROGSLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo
		echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ FROGS Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN OLOG"      | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG"     "OLOG"      "$HUMANBATCHSTDOUT" "$FROGSJOBSUB" ; then continue ; fi
            
			ELOG=$(     echo "$RUNDATA"  | grep "RUN $ARUN ELOG"      | awk '{ print $4 }' )
            if filenameIsNotHealthy "$ELOG"     "ELOG"      "$HUMANBATCHSTDERR" "$FROGSJOBSUB" ; then continue ; fi
            
            DATAFILE=$( cat "$OLOG"      | grep "RUN$ARUN FROGSDATA" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "FROGSDATA" "frogs datafile"    "$OLOG"        ; then continue ; fi
            
            FROGSLOG=$( cat "$OLOG"      | grep "RUN$ARUN FROGSLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$FROGSLOG" "FROGSLOG"  "frogs log file"    "$OLOG"        ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$FROGSLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$FROGSLOG" "Final checks on result file (seems to be OK)" )
            printf "%10s is %s, last modified %19s %12s %10s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
		done < $RUNLIST
	fi
fi

# s4 anasum_parallel (anpar)
if [[ "$STAGE" == "anpar" ]] ; then
	ANPARJOBSUB="$SCIDIR/qsubdata.anpar"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# anpar #########################################################
		makeParamFile
		echo "$STAGE" > "$STAGEFILE"
        checkForFASTDEVMODE
		cd $EVNDISPSYS/scripts/VTS
		
		# decide input directory
        if [[ "$USEFROGS" == "yes" ]] ; then 
            INPUTANASUMDIR="$FROGSOUTPUTDIR"
            echo -e "${COTYELLOW}Using frogs files as input...$CONORM"
        else
            INPUTANASUMDIR="$EVNDISPOUTPUTDIR/RecID${RECID}"
            echo -e "Using mscw files as input..."
        fi
		
		QSUBDATA=$( ./ANALYSIS.anasum_parallel.sh "$ANASUMRUNLIST" "$ANASUMOUTPUTDIR" "$RUNPARAMFILE" "$INPUTANASUMDIR" | tee >(cat - >&5) )
		updateRunningJobFile "$QSUBDATA"
		rm -rf "$ANPARJOBSUB"
        echo "$QSUBDATA" > "$ANPARJOBSUB"
        sleep 2
	else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# anpar check #########################################################
        
        # check qsub submission text for problems
        echo -e "${COTBLUE}checking job submission text...${CONORM}"
        checkLogFileForProblems "$ANPARJOBSUB" $DEBUGREGEX
        echo
        
        # check batch jobs, if we can
        checkBatchJobExits "$ANPARJOBSUB" "$RUNLIST"
        echo
        
		QSUBDATA=$( cat $ANPARJOBSUB )
		for ARUN in $RUNNUMBERS ; do # check batch and log files
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
			SCRIPT=$(  echo "$RUNDATA"  | grep "RUN $ARUN SCRIPT" | awk '{ print $4 }' )
            
			OLOG=$( echo "$RUNDATA" | grep "RUN $ARUN OLOG" | awk '{ print $4 }' )
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$ANPARJOBSUB" ; then continue ; fi
			checkLogFileForProblems "$OLOG" $DEBUGREGEX
            
			ELOG=$( echo "$RUNDATA" | grep "RUN $ARUN ELOG" | awk '{ print $4 }' )
			checkLogFileForProblems "$ELOG" $DEBUGREGEX
            if filenameIsNotHealthy "$ELOG" "ELOG" "$HUMANBATCHSTDERR" "$ANPARJOBSUB" ; then continue ; fi
            
            ANPARLOG=$( cat "$OLOG" | grep "RUN$ARUN ANPARLOG" | awk '{ print $3 }' )
            if filenameIsNotHealthy "$ANPARLOG" "ANPARLOG" "anasum parallel log file" "$OLOG" ; then continue ; fi
            checkLogFileForProblems "$ANPARLOG" $DEBUGREGEX
             
            checkLogFileForStageSuccess "$ANPARLOG" "analysis results written to"
		done < $RUNLIST
		
		OLOG=$(  echo "$QSUBDATA" | grep -P "^RUN \d+ OLOG"     | head -n 1 | awk '{ print $4 }' )
		DFDIR=$( cat $OLOG        | grep -P "^RUN\d{5} ANPARLOG" | awk '{ print $3 }' )
		DFDIR=$( dirname $DFDIR )
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ ANASUM Datafiles stored in $DFDIR/$CONORM"
		while read ARUN ; do
			RUNDATA=$( echo "$QSUBDATA" | grep -P "^RUN $ARUN" )
            
			OLOG=$(    echo "$RUNDATA"  | grep "RUN $ARUN OLOG"   | awk '{ print $4 }')
            if filenameIsNotHealthy "$OLOG" "OLOG" "$HUMANBATCHSTDOUT" "$ANPARJOBSUB"        ; then continue ; fi
            
            ANPARLOG=$(  cat "$OLOG" | grep "RUN$ARUN ANPARLOG"  | awk '{ print $3 }' )
            if filenameIsNotHealthy "$ANPARLOG" "ANPARLOG" "anasum parallel log file" "$OLOG"  ; then continue ; fi
            
            DATAFILE=$(  cat "$OLOG" | grep "RUN$ARUN ANPARDATA"   | awk '{ print $3 }' )
            if filenameIsNotHealthy "$DATAFILE" "ANPARDATA" "anasum parallel datafile" "$OLOG"   ; then continue ; fi
            
            LOGFILES=("$OLOG" "$ELOG" "$ANPARLOG" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            RUNSIGMA=$( grep -E "ALL RUNS" "$ANPARLOG" | grep -oP '\d{1,3}\.\d{0,2} sigma' | grep -oP '\d{1,3}\.\d{0,2}')
            
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            RUNSUCCESS=$( checkForSuccess "$ANPARLOG" "analysis results written to" )
            printf "%10s is %s, last modified %19s sigma=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$RUNSIGMA" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
            
		done < $RUNLIST

	fi
fi

# s5 anasum
if [[ "$STAGE" == "anmer" ]] ; then
	FINALOUTPUTLOG="${ANASUMOUTPUTDIR}/`basename $FINALOUTPUT .root`.log"
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# anmer #############################################################################
		makeParamFile
		echo "$STAGE" > "$STAGEFILE"
		cd $EVNDISPSYS/scripts/VTS
		nice -n 19 ./ANALYSIS.anasum_combine.sh $ANASUMRUNLIST $ANASUMOUTPUTDIR $FINALOUTPUT $RUNPARAMFILE | tee "$FINALOUTPUTLOG"
		updateRunningJobFile ""
     
    else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# anmer check ######################################################################
        if filenameIsNotHealthy "$FINALOUTPUTLOG" "(filename constructed in ANALYSIS.pipeline)" "merged anasum log file" "ANALYSIS.pipeline"  ; then continue ; fi
		checkLogFileForProblems $FINALOUTPUTLOG $DEBUGREGEX
        
		DATAFILE="${ANASUMOUTPUTDIR}/${FINALOUTPUT}"
        if filenameIsNotHealthy "$DATAFILE" "FINALOUTPUT" "merge anasum datafile" "ANALYSIS.pipeline"  ; then continue ; fi
        
        LOGFILES=( "$FINALOUTPUTLOG" )
        WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
        ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
        RUNSIGMA=$( grep -E "ALL RUNS" "$FINALOUTPUTLOG" | grep -oP '\d{1,3}\.\d{0,2} sigma' | grep -oP '\d{1,3}\.\d{0,2}')
        
        DFBASE=$( basename $DATAFILE )
        DFSIZE=`stat -c %s $DATAFILE`
        DFSIZESTR=$( formatFileSize "$DFSIZE" )
        DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
        printf "%10s is %s, last modified %19s sigma=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$RUNSIGMA" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
	fi
fi

# s6 mutate : (convert) Anasum Parallel files to CTOOL's Data Format$
if [[ "$STAGE" == "mutate" ]] ; then
	if ! $CHECKFLAG ; then
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		
		# check that anasum run parameter file has the WRITEEVENTTREEFORCTOOLS
		GOODSETTING=$( cat "$RUNPARAMFILE" | grep -P "^\*\s+WRITEEVENTTREEFORCTOOLS\s+1")
		if [ -z "$GOODSETTING" ] ; then
			echo -e "${COTYELLOW}Warning, you're trying to convert anasum files to ctool's fits format, but ${COTRED}these anasum files may not have been made with the '* WRITEEVENTTREEFORCTOOLS 1' option${COTYELLOW} in its Anasum Parameter File: '$RUNPARAMFILE'${CONORM}"
			echo -e "${COTYELLOW}  There is a very good chance this stage will fail.$CONORM"
		fi
		
        
		# mutate ###################################################3
        cd $EVNDISPSYS/bin
        echo "now here: $PWD"
        echo "output data going here: $CTOOLSDIR"
        while read ARUN ; do
            # this stage runs quite fast (~10seconds per run)
            # so we wont run it in parallel
            #echo "$ANASUMOUTPUTDIR/$ARUN.anasum.root"
            echo "Producing $CTOOLSDIR/$ARUN.ctools.fits ..."
            writeCTAEventListFromAnasum -f -i "$ANASUMOUTPUTDIR/$ARUN.anasum.root" -o "$CTOOLSDIR/$ARUN.ctools.fits" >  "$CTOOLSDIR/$ARUN.ctools.log" 2>&1  
            #echo
        done < $RUNLIST
        
    else
		haltIfAnyJobsAreRunning $RUNNINGJOBS
		stageBanner
		# mutate check ###################################################3
        
        # check log files
        while read ARUN ; do
			echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~" ; echo -e "~~~~~~~~~~~ Run:$ARUN${CONORM}"
            CTOOLSLOG="$CTOOLSDIR/$ARUN.ctools.log"
            checkLogFileForProblems     "$CTOOLSLOG" $DEBUGREGEX
            checkLogFileForStageSuccess "$CTOOLSLOG" "Conversion from .* complete"
        done < $RUNLIST
        
        # check data files
		echo ; echo -e "${COBLUE}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		echo -e "~~~~~~~~~~~ CTOOLS Datafiles stored in $CTOOLSDIR/$CONORM"
        while read ARUN ; do
            LOGFILES=("$CTOOLSDIR/$ARUN.ctools.log" )
            WARNCOUNTSTR=$(  formatwarncount  LOGFILES[@] )
            ERRORCOUNTSTR=$( formaterrorcount LOGFILES[@] )
            
            DATAFILE="$CTOOLSDIR/$ARUN.ctools.fits"
            DFBASE=$( basename $DATAFILE )
            DFSIZE=`stat -c %s $DATAFILE`
            DFSIZESTR=$( formatFileSize "$DFSIZE" )
            DFMODDATE=`stat -c %y $DATAFILE | cut -f1 -d.`
            NEVENTS=$( cat "$CTOOLSDIR/$ARUN.ctools.log" | grep -P "RunNumber \d+, \d+ events written." | grep -oP ", \d+ events" | grep -oP "\d+" )
            RUNSUCCESS=$( checkForSuccess "$CTOOLSDIR/$ARUN.ctools.log" "Conversion from .* complete" )
            printf "%10s is %s, last modified %19s events=%5s %12s %11s  : %s\n" "$DFBASE" "$DFSIZESTR" "$DFMODDATE" "$NEVENTS" "$WARNCOUNTSTR" "$ERRORCOUNTSTR" "$RUNSUCCESS"
        done < $RUNLIST
    fi
fi
